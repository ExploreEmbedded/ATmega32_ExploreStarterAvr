
RTC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000010ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000028  00800060  000010ae  00001142  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000010  00800088  00800088  0000116a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000116a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000119c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000190  00000000  00000000  000011d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001d59  00000000  00000000  00001368  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000007e0  00000000  00000000  000030c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000076b  00000000  00000000  000038a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000438  00000000  00000000  0000400c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000769  00000000  00000000  00004444  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001790  00000000  00000000  00004bad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000178  00000000  00000000  0000633d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee ea       	ldi	r30, 0xAE	; 174
      68:	f0 e1       	ldi	r31, 0x10	; 16
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 38       	cpi	r26, 0x88	; 136
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	20 e0       	ldi	r18, 0x00	; 0
      78:	a8 e8       	ldi	r26, 0x88	; 136
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 39       	cpi	r26, 0x98	; 152
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 de 05 	call	0xbbc	; 0xbbc <main>
      8a:	0c 94 55 08 	jmp	0x10aa	; 0x10aa <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DELAY_us>:
         if 5000 is passed as the argument then it generates a delay of 5ms.		  

 ***************************************************************************************************/
void DELAY_us(uint16_t us_count) 
{
    while (us_count != 0) 
      92:	00 97       	sbiw	r24, 0x00	; 0
      94:	31 f0       	breq	.+12     	; 0xa2 <DELAY_us+0x10>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
      96:	25 e0       	ldi	r18, 0x05	; 5
      98:	2a 95       	dec	r18
      9a:	f1 f7       	brne	.-4      	; 0x98 <DELAY_us+0x6>
      9c:	00 00       	nop
    {
        _delay_us(1);
		us_count--;
      9e:	01 97       	sbiw	r24, 0x01	; 1
      a0:	f8 cf       	rjmp	.-16     	; 0x92 <DELAY_us>
    }
}
      a2:	08 95       	ret

000000a4 <DELAY_ms>:
     It generates a delay of 1ms for each count,
     if 1000 is passed as the argument then it generates delay of 1000ms(1sec)
 ***************************************************************************************************/
void DELAY_ms(uint16_t ms_count) 
{
    while (ms_count != 0) 
      a4:	00 97       	sbiw	r24, 0x00	; 0
      a6:	41 f0       	breq	.+16     	; 0xb8 <DELAY_ms+0x14>
      a8:	ef e9       	ldi	r30, 0x9F	; 159
      aa:	ff e0       	ldi	r31, 0x0F	; 15
      ac:	31 97       	sbiw	r30, 0x01	; 1
      ae:	f1 f7       	brne	.-4      	; 0xac <DELAY_ms+0x8>
      b0:	00 c0       	rjmp	.+0      	; 0xb2 <DELAY_ms+0xe>
      b2:	00 00       	nop
    {
        _delay_us(1000); //DELAY_us is called to generate 1ms delay
        ms_count--;
      b4:	01 97       	sbiw	r24, 0x01	; 1
      b6:	f6 cf       	rjmp	.-20     	; 0xa4 <DELAY_ms>
    }
}
      b8:	08 95       	ret

000000ba <GPIO_PinDirection>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
      ba:	98 2f       	mov	r25, r24
      bc:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
      be:	86 95       	lsr	r24
      c0:	86 95       	lsr	r24
      c2:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        set the direction as specified*/
    switch(v_portNumber_u8)
      c4:	81 30       	cpi	r24, 0x01	; 1
      c6:	01 f1       	breq	.+64     	; 0x108 <GPIO_PinDirection+0x4e>
      c8:	30 f0       	brcs	.+12     	; 0xd6 <GPIO_PinDirection+0x1c>
      ca:	82 30       	cpi	r24, 0x02	; 2
      cc:	b1 f1       	breq	.+108    	; 0x13a <GPIO_PinDirection+0x80>
      ce:	83 30       	cpi	r24, 0x03	; 3
      d0:	09 f4       	brne	.+2      	; 0xd4 <GPIO_PinDirection+0x1a>
      d2:	4c c0       	rjmp	.+152    	; 0x16c <GPIO_PinDirection+0xb2>
      d4:	08 95       	ret
    {
#ifdef DDRA        
    case 0:
        util_UpdateBit(DDRA,enm_pinNumber,v_pinDirn_u8);
      d6:	4a b3       	in	r20, 0x1a	; 26
      d8:	21 e0       	ldi	r18, 0x01	; 1
      da:	30 e0       	ldi	r19, 0x00	; 0
      dc:	66 23       	and	r22, r22
      de:	49 f0       	breq	.+18     	; 0xf2 <GPIO_PinDirection+0x38>
      e0:	b9 01       	movw	r22, r18
      e2:	02 c0       	rjmp	.+4      	; 0xe8 <GPIO_PinDirection+0x2e>
      e4:	66 0f       	add	r22, r22
      e6:	77 1f       	adc	r23, r23
      e8:	9a 95       	dec	r25
      ea:	e2 f7       	brpl	.-8      	; 0xe4 <GPIO_PinDirection+0x2a>
      ec:	cb 01       	movw	r24, r22
      ee:	84 2b       	or	r24, r20
      f0:	09 c0       	rjmp	.+18     	; 0x104 <GPIO_PinDirection+0x4a>
      f2:	b9 01       	movw	r22, r18
      f4:	02 c0       	rjmp	.+4      	; 0xfa <GPIO_PinDirection+0x40>
      f6:	66 0f       	add	r22, r22
      f8:	77 1f       	adc	r23, r23
      fa:	9a 95       	dec	r25
      fc:	e2 f7       	brpl	.-8      	; 0xf6 <GPIO_PinDirection+0x3c>
      fe:	cb 01       	movw	r24, r22
     100:	80 95       	com	r24
     102:	84 23       	and	r24, r20
     104:	8a bb       	out	0x1a, r24	; 26
     106:	08 95       	ret
#endif        


#ifdef DDRB
    case 1:
        util_UpdateBit(DDRB,enm_pinNumber,v_pinDirn_u8);
     108:	47 b3       	in	r20, 0x17	; 23
     10a:	21 e0       	ldi	r18, 0x01	; 1
     10c:	30 e0       	ldi	r19, 0x00	; 0
     10e:	66 23       	and	r22, r22
     110:	49 f0       	breq	.+18     	; 0x124 <GPIO_PinDirection+0x6a>
     112:	b9 01       	movw	r22, r18
     114:	02 c0       	rjmp	.+4      	; 0x11a <GPIO_PinDirection+0x60>
     116:	66 0f       	add	r22, r22
     118:	77 1f       	adc	r23, r23
     11a:	9a 95       	dec	r25
     11c:	e2 f7       	brpl	.-8      	; 0x116 <GPIO_PinDirection+0x5c>
     11e:	cb 01       	movw	r24, r22
     120:	84 2b       	or	r24, r20
     122:	09 c0       	rjmp	.+18     	; 0x136 <GPIO_PinDirection+0x7c>
     124:	b9 01       	movw	r22, r18
     126:	02 c0       	rjmp	.+4      	; 0x12c <GPIO_PinDirection+0x72>
     128:	66 0f       	add	r22, r22
     12a:	77 1f       	adc	r23, r23
     12c:	9a 95       	dec	r25
     12e:	e2 f7       	brpl	.-8      	; 0x128 <GPIO_PinDirection+0x6e>
     130:	cb 01       	movw	r24, r22
     132:	80 95       	com	r24
     134:	84 23       	and	r24, r20
     136:	87 bb       	out	0x17, r24	; 23
     138:	08 95       	ret
#endif 

        
#ifdef DDRC
    case 2:
        util_UpdateBit(DDRC,enm_pinNumber,v_pinDirn_u8);
     13a:	44 b3       	in	r20, 0x14	; 20
     13c:	21 e0       	ldi	r18, 0x01	; 1
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	66 23       	and	r22, r22
     142:	49 f0       	breq	.+18     	; 0x156 <GPIO_PinDirection+0x9c>
     144:	b9 01       	movw	r22, r18
     146:	02 c0       	rjmp	.+4      	; 0x14c <GPIO_PinDirection+0x92>
     148:	66 0f       	add	r22, r22
     14a:	77 1f       	adc	r23, r23
     14c:	9a 95       	dec	r25
     14e:	e2 f7       	brpl	.-8      	; 0x148 <GPIO_PinDirection+0x8e>
     150:	cb 01       	movw	r24, r22
     152:	84 2b       	or	r24, r20
     154:	09 c0       	rjmp	.+18     	; 0x168 <GPIO_PinDirection+0xae>
     156:	b9 01       	movw	r22, r18
     158:	02 c0       	rjmp	.+4      	; 0x15e <GPIO_PinDirection+0xa4>
     15a:	66 0f       	add	r22, r22
     15c:	77 1f       	adc	r23, r23
     15e:	9a 95       	dec	r25
     160:	e2 f7       	brpl	.-8      	; 0x15a <GPIO_PinDirection+0xa0>
     162:	cb 01       	movw	r24, r22
     164:	80 95       	com	r24
     166:	84 23       	and	r24, r20
     168:	84 bb       	out	0x14, r24	; 20
     16a:	08 95       	ret
#endif 

        
#ifdef DDRD        
    case 3:
        util_UpdateBit(DDRD,enm_pinNumber,v_pinDirn_u8);
     16c:	41 b3       	in	r20, 0x11	; 17
     16e:	21 e0       	ldi	r18, 0x01	; 1
     170:	30 e0       	ldi	r19, 0x00	; 0
     172:	66 23       	and	r22, r22
     174:	49 f0       	breq	.+18     	; 0x188 <GPIO_PinDirection+0xce>
     176:	b9 01       	movw	r22, r18
     178:	02 c0       	rjmp	.+4      	; 0x17e <GPIO_PinDirection+0xc4>
     17a:	66 0f       	add	r22, r22
     17c:	77 1f       	adc	r23, r23
     17e:	9a 95       	dec	r25
     180:	e2 f7       	brpl	.-8      	; 0x17a <GPIO_PinDirection+0xc0>
     182:	cb 01       	movw	r24, r22
     184:	84 2b       	or	r24, r20
     186:	09 c0       	rjmp	.+18     	; 0x19a <GPIO_PinDirection+0xe0>
     188:	b9 01       	movw	r22, r18
     18a:	02 c0       	rjmp	.+4      	; 0x190 <GPIO_PinDirection+0xd6>
     18c:	66 0f       	add	r22, r22
     18e:	77 1f       	adc	r23, r23
     190:	9a 95       	dec	r25
     192:	e2 f7       	brpl	.-8      	; 0x18c <GPIO_PinDirection+0xd2>
     194:	cb 01       	movw	r24, r22
     196:	80 95       	com	r24
     198:	84 23       	and	r24, r20
     19a:	81 bb       	out	0x11, r24	; 17
     19c:	08 95       	ret

0000019e <GPIO_PinWrite>:

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 
     19e:	98 2f       	mov	r25, r24
     1a0:	97 70       	andi	r25, 0x07	; 7
{

    uint8_t v_portNumber_u8;


    v_portNumber_u8 =  (enm_pinNumber>>3);  // Divide the pin number by 8 go get the PORT number
     1a2:	86 95       	lsr	r24
     1a4:	86 95       	lsr	r24
     1a6:	86 95       	lsr	r24
    enm_pinNumber  =   enm_pinNumber & 0x07;  // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and 
        update the value of the specified pin*/
    switch(v_portNumber_u8)
     1a8:	81 30       	cpi	r24, 0x01	; 1
     1aa:	01 f1       	breq	.+64     	; 0x1ec <GPIO_PinWrite+0x4e>
     1ac:	30 f0       	brcs	.+12     	; 0x1ba <GPIO_PinWrite+0x1c>
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	b1 f1       	breq	.+108    	; 0x21e <GPIO_PinWrite+0x80>
     1b2:	83 30       	cpi	r24, 0x03	; 3
     1b4:	09 f4       	brne	.+2      	; 0x1b8 <GPIO_PinWrite+0x1a>
     1b6:	4c c0       	rjmp	.+152    	; 0x250 <GPIO_PinWrite+0xb2>
     1b8:	08 95       	ret
    {
#ifdef PORTA        
    case 0:
        util_UpdateBit(PORTA,enm_pinNumber,v_pinValue_u8);
     1ba:	4b b3       	in	r20, 0x1b	; 27
     1bc:	21 e0       	ldi	r18, 0x01	; 1
     1be:	30 e0       	ldi	r19, 0x00	; 0
     1c0:	66 23       	and	r22, r22
     1c2:	49 f0       	breq	.+18     	; 0x1d6 <GPIO_PinWrite+0x38>
     1c4:	b9 01       	movw	r22, r18
     1c6:	02 c0       	rjmp	.+4      	; 0x1cc <GPIO_PinWrite+0x2e>
     1c8:	66 0f       	add	r22, r22
     1ca:	77 1f       	adc	r23, r23
     1cc:	9a 95       	dec	r25
     1ce:	e2 f7       	brpl	.-8      	; 0x1c8 <GPIO_PinWrite+0x2a>
     1d0:	cb 01       	movw	r24, r22
     1d2:	84 2b       	or	r24, r20
     1d4:	09 c0       	rjmp	.+18     	; 0x1e8 <GPIO_PinWrite+0x4a>
     1d6:	b9 01       	movw	r22, r18
     1d8:	02 c0       	rjmp	.+4      	; 0x1de <GPIO_PinWrite+0x40>
     1da:	66 0f       	add	r22, r22
     1dc:	77 1f       	adc	r23, r23
     1de:	9a 95       	dec	r25
     1e0:	e2 f7       	brpl	.-8      	; 0x1da <GPIO_PinWrite+0x3c>
     1e2:	cb 01       	movw	r24, r22
     1e4:	80 95       	com	r24
     1e6:	84 23       	and	r24, r20
     1e8:	8b bb       	out	0x1b, r24	; 27
     1ea:	08 95       	ret
#endif        

        
#ifdef PORTB
    case 1:
        util_UpdateBit(PORTB,enm_pinNumber,v_pinValue_u8);
     1ec:	48 b3       	in	r20, 0x18	; 24
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	66 23       	and	r22, r22
     1f4:	49 f0       	breq	.+18     	; 0x208 <GPIO_PinWrite+0x6a>
     1f6:	b9 01       	movw	r22, r18
     1f8:	02 c0       	rjmp	.+4      	; 0x1fe <GPIO_PinWrite+0x60>
     1fa:	66 0f       	add	r22, r22
     1fc:	77 1f       	adc	r23, r23
     1fe:	9a 95       	dec	r25
     200:	e2 f7       	brpl	.-8      	; 0x1fa <GPIO_PinWrite+0x5c>
     202:	cb 01       	movw	r24, r22
     204:	84 2b       	or	r24, r20
     206:	09 c0       	rjmp	.+18     	; 0x21a <GPIO_PinWrite+0x7c>
     208:	b9 01       	movw	r22, r18
     20a:	02 c0       	rjmp	.+4      	; 0x210 <GPIO_PinWrite+0x72>
     20c:	66 0f       	add	r22, r22
     20e:	77 1f       	adc	r23, r23
     210:	9a 95       	dec	r25
     212:	e2 f7       	brpl	.-8      	; 0x20c <GPIO_PinWrite+0x6e>
     214:	cb 01       	movw	r24, r22
     216:	80 95       	com	r24
     218:	84 23       	and	r24, r20
     21a:	88 bb       	out	0x18, r24	; 24
     21c:	08 95       	ret
#endif        

        
#ifdef PORTC        
    case 2:
        util_UpdateBit(PORTC,enm_pinNumber,v_pinValue_u8);
     21e:	45 b3       	in	r20, 0x15	; 21
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	66 23       	and	r22, r22
     226:	49 f0       	breq	.+18     	; 0x23a <GPIO_PinWrite+0x9c>
     228:	b9 01       	movw	r22, r18
     22a:	02 c0       	rjmp	.+4      	; 0x230 <GPIO_PinWrite+0x92>
     22c:	66 0f       	add	r22, r22
     22e:	77 1f       	adc	r23, r23
     230:	9a 95       	dec	r25
     232:	e2 f7       	brpl	.-8      	; 0x22c <GPIO_PinWrite+0x8e>
     234:	cb 01       	movw	r24, r22
     236:	84 2b       	or	r24, r20
     238:	09 c0       	rjmp	.+18     	; 0x24c <GPIO_PinWrite+0xae>
     23a:	b9 01       	movw	r22, r18
     23c:	02 c0       	rjmp	.+4      	; 0x242 <GPIO_PinWrite+0xa4>
     23e:	66 0f       	add	r22, r22
     240:	77 1f       	adc	r23, r23
     242:	9a 95       	dec	r25
     244:	e2 f7       	brpl	.-8      	; 0x23e <GPIO_PinWrite+0xa0>
     246:	cb 01       	movw	r24, r22
     248:	80 95       	com	r24
     24a:	84 23       	and	r24, r20
     24c:	85 bb       	out	0x15, r24	; 21
     24e:	08 95       	ret
#endif        

        
#ifdef PORTD        
    case 3:
        util_UpdateBit(PORTD,enm_pinNumber,v_pinValue_u8);
     250:	42 b3       	in	r20, 0x12	; 18
     252:	21 e0       	ldi	r18, 0x01	; 1
     254:	30 e0       	ldi	r19, 0x00	; 0
     256:	66 23       	and	r22, r22
     258:	49 f0       	breq	.+18     	; 0x26c <GPIO_PinWrite+0xce>
     25a:	b9 01       	movw	r22, r18
     25c:	02 c0       	rjmp	.+4      	; 0x262 <GPIO_PinWrite+0xc4>
     25e:	66 0f       	add	r22, r22
     260:	77 1f       	adc	r23, r23
     262:	9a 95       	dec	r25
     264:	e2 f7       	brpl	.-8      	; 0x25e <GPIO_PinWrite+0xc0>
     266:	cb 01       	movw	r24, r22
     268:	84 2b       	or	r24, r20
     26a:	09 c0       	rjmp	.+18     	; 0x27e <GPIO_PinWrite+0xe0>
     26c:	b9 01       	movw	r22, r18
     26e:	02 c0       	rjmp	.+4      	; 0x274 <GPIO_PinWrite+0xd6>
     270:	66 0f       	add	r22, r22
     272:	77 1f       	adc	r23, r23
     274:	9a 95       	dec	r25
     276:	e2 f7       	brpl	.-8      	; 0x270 <GPIO_PinWrite+0xd2>
     278:	cb 01       	movw	r24, r22
     27a:	80 95       	com	r24
     27c:	84 23       	and	r24, r20
     27e:	82 bb       	out	0x12, r24	; 18
     280:	08 95       	ret

00000282 <GPIO_PinRead>:
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 
     282:	28 2f       	mov	r18, r24
     284:	27 70       	andi	r18, 0x07	; 7
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;

    v_portNumber_u8 =  (enm_pinNumber>>3); // Divide the pin number by 8 go get the PORT number
     286:	86 95       	lsr	r24
     288:	86 95       	lsr	r24
     28a:	86 95       	lsr	r24
    enm_pinNumber  =     enm_pinNumber & 0x07; // lower 3-bits contains the bit number of a byte 

    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
     28c:	81 30       	cpi	r24, 0x01	; 1
     28e:	49 f0       	breq	.+18     	; 0x2a2 <GPIO_PinRead+0x20>
     290:	30 f0       	brcs	.+12     	; 0x29e <GPIO_PinRead+0x1c>
     292:	82 30       	cpi	r24, 0x02	; 2
     294:	41 f0       	breq	.+16     	; 0x2a6 <GPIO_PinRead+0x24>
     296:	83 30       	cpi	r24, 0x03	; 3
     298:	79 f4       	brne	.+30     	; 0x2b8 <GPIO_PinRead+0x36>
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
     29a:	80 b3       	in	r24, 0x10	; 16
     29c:	05 c0       	rjmp	.+10     	; 0x2a8 <GPIO_PinRead+0x26>
    /* Go to particular port after decoding from the pin number and read the pins status */
    switch(v_portNumber_u8)     
    { 
#ifdef PINA    
    case 0: 
        returnStatus = util_IsBitSet(PINA,enm_pinNumber);
     29e:	89 b3       	in	r24, 0x19	; 25
     2a0:	03 c0       	rjmp	.+6      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif        

#ifdef PINB
    case 1:
        returnStatus = util_IsBitSet(PINB,enm_pinNumber);
     2a2:	86 b3       	in	r24, 0x16	; 22
     2a4:	01 c0       	rjmp	.+2      	; 0x2a8 <GPIO_PinRead+0x26>
        break;
#endif          

#ifdef PINC
    case 2:
        returnStatus = util_IsBitSet(PINC,enm_pinNumber);
     2a6:	83 b3       	in	r24, 0x13	; 19
#endif        
        
        
#ifdef PIND
    case 3:
        returnStatus = util_IsBitSet(PIND,enm_pinNumber);
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	02 c0       	rjmp	.+4      	; 0x2b0 <GPIO_PinRead+0x2e>
     2ac:	95 95       	asr	r25
     2ae:	87 95       	ror	r24
     2b0:	2a 95       	dec	r18
     2b2:	e2 f7       	brpl	.-8      	; 0x2ac <GPIO_PinRead+0x2a>
     2b4:	81 70       	andi	r24, 0x01	; 1
        break;
     2b6:	08 95       	ret
                Before reading the pins status, the pin should be configured as INPUT 
 ***************************************************************************************************/
uint8_t GPIO_PinRead(gpioPins_et enm_pinNumber)
{
    uint8_t v_portNumber_u8;
    uint8_t returnStatus = 0;
     2b8:	80 e0       	ldi	r24, 0x00	; 0
        returnStatus = util_IsBitSet(PING,enm_pinNumber);
        break;
#endif             
    }                         
    return returnStatus;
}
     2ba:	08 95       	ret

000002bc <I2C_Init>:

 * description :This function is used to initialize the I2C module
------------------------------------------------------------------------------------*/
void I2C_Init()
{
    TWSR=0x00; //set presca1er bits to zero
     2bc:	11 b8       	out	0x01, r1	; 1
    TWBR=0x46; //SCL frequency is 50K for 16Mhz
     2be:	86 e4       	ldi	r24, 0x46	; 70
     2c0:	80 b9       	out	0x00, r24	; 0
    TWCR=0x04; //enab1e TWI module
     2c2:	84 e0       	ldi	r24, 0x04	; 4
     2c4:	86 bf       	out	0x36, r24	; 54
     2c6:	08 95       	ret

000002c8 <I2C_Start>:
                      ____|         |____________

 ***************************************************************************************************/
void I2C_Start()
{
    TWCR = ((1<<TWINT) | (1<<TWSTA) | (1<<TWEN));
     2c8:	84 ea       	ldi	r24, 0xA4	; 164
     2ca:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1<<TWINT)));
     2cc:	06 b6       	in	r0, 0x36	; 54
     2ce:	07 fe       	sbrs	r0, 7
     2d0:	fd cf       	rjmp	.-6      	; 0x2cc <I2C_Start+0x4>
}
     2d2:	08 95       	ret

000002d4 <I2C_Stop>:

 ***************************************************************************************************/

void I2C_Stop(void)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (1<<TWSTO));
     2d4:	84 e9       	ldi	r24, 0x94	; 148
     2d6:	86 bf       	out	0x36, r24	; 54
    DELAY_us(100) ; //wait for a short time
     2d8:	84 e6       	ldi	r24, 0x64	; 100
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	0c 94 49 00 	jmp	0x92	; 0x92 <DELAY_us>

000002e0 <I2C_Write>:


 ***************************************************************************************************/
void I2C_Write(uint8_t v_i2cData_u8)
{
    TWDR = v_i2cData_u8 ;
     2e0:	83 b9       	out	0x03, r24	; 3
    TWCR = ((1<< TWINT) | (1<<TWEN));
     2e2:	84 e8       	ldi	r24, 0x84	; 132
     2e4:	86 bf       	out	0x36, r24	; 54
    while (!(TWCR & (1 <<TWINT)));
     2e6:	06 b6       	in	r0, 0x36	; 54
     2e8:	07 fe       	sbrs	r0, 7
     2ea:	fd cf       	rjmp	.-6      	; 0x2e6 <I2C_Write+0x6>
}
     2ec:	08 95       	ret

000002ee <I2C_Read>:


***************************************************************************************************/
uint8_t I2C_Read(uint8_t v_ackOption_u8)
{
    TWCR = ((1<< TWINT) | (1<<TWEN) | (v_ackOption_u8<<TWEA));
     2ee:	20 e4       	ldi	r18, 0x40	; 64
     2f0:	82 9f       	mul	r24, r18
     2f2:	c0 01       	movw	r24, r0
     2f4:	11 24       	eor	r1, r1
     2f6:	84 68       	ori	r24, 0x84	; 132
     2f8:	86 bf       	out	0x36, r24	; 54
    while ( !(TWCR & (1 <<TWINT)));
     2fa:	06 b6       	in	r0, 0x36	; 54
     2fc:	07 fe       	sbrs	r0, 7
     2fe:	fd cf       	rjmp	.-6      	; 0x2fa <I2C_Read+0xc>
    return TWDR;
     300:	83 b1       	in	r24, 0x03	; 3
}
     302:	08 95       	ret

00000304 <lcd_SendHigherNibble>:
 * Return value    : none

 * description : This functions is used to send the higher nibble of the data to LCD in 4-bit mode
**************************************************************************************************/
static void lcd_SendHigherNibble(uint8_t dataByte)
{
     304:	0f 93       	push	r16
     306:	1f 93       	push	r17
     308:	cf 93       	push	r28
     30a:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
     30c:	84 fb       	bst	r24, 4
     30e:	66 27       	eor	r22, r22
     310:	60 f9       	bld	r22, 0
     312:	08 e8       	ldi	r16, 0x88	; 136
     314:	10 e0       	ldi	r17, 0x00	; 0
     316:	f8 01       	movw	r30, r16
     318:	82 85       	ldd	r24, Z+10	; 0x0a
     31a:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
     31e:	c5 fb       	bst	r28, 5
     320:	66 27       	eor	r22, r22
     322:	60 f9       	bld	r22, 0
     324:	f8 01       	movw	r30, r16
     326:	83 85       	ldd	r24, Z+11	; 0x0b
     328:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
     32c:	c6 fb       	bst	r28, 6
     32e:	66 27       	eor	r22, r22
     330:	60 f9       	bld	r22, 0
     332:	f8 01       	movw	r30, r16
     334:	84 85       	ldd	r24, Z+12	; 0x0c
     336:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
     33a:	6c 2f       	mov	r22, r28
     33c:	66 1f       	adc	r22, r22
     33e:	66 27       	eor	r22, r22
     340:	66 1f       	adc	r22, r22
     342:	f8 01       	movw	r30, r16
     344:	85 85       	ldd	r24, Z+13	; 0x0d
}
     346:	cf 91       	pop	r28
     348:	1f 91       	pop	r17
     34a:	0f 91       	pop	r16
static void lcd_SendHigherNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D4,util_IsBitSet(dataByte,4));
    GPIO_PinWrite(LCDConfig.D5,util_IsBitSet(dataByte,5));
    GPIO_PinWrite(LCDConfig.D6,util_IsBitSet(dataByte,6));
    GPIO_PinWrite(LCDConfig.D7,util_IsBitSet(dataByte,7));
     34c:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000350 <lcd_SendCmdSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the v_lcdCmd_u8 to LCD
**************************************************************************************************/
static void lcd_SendCmdSignals(void)
{
     350:	cf 93       	push	r28
     352:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,0);
     354:	c8 e8       	ldi	r28, 0x88	; 136
     356:	d0 e0       	ldi	r29, 0x00	; 0
     358:	60 e0       	ldi	r22, 0x00	; 0
     35a:	8b 81       	ldd	r24, Y+3	; 0x03
     35c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
     360:	60 e0       	ldi	r22, 0x00	; 0
     362:	8c 81       	ldd	r24, Y+4	; 0x04
     364:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
     368:	61 e0       	ldi	r22, 0x01	; 1
     36a:	8d 81       	ldd	r24, Y+5	; 0x05
     36c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
     370:	8a e0       	ldi	r24, 0x0A	; 10
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
     378:	60 e0       	ldi	r22, 0x00	; 0
     37a:	8d 81       	ldd	r24, Y+5	; 0x05
  
}
     37c:	df 91       	pop	r29
     37e:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,0);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
     380:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000384 <lcd_SendLowerNibble>:
 * Return value    : none

 * description : This functions is used to send the lower nibble of the data to LCD
**************************************************************************************************/
static void lcd_SendLowerNibble(uint8_t dataByte)
{
     384:	0f 93       	push	r16
     386:	1f 93       	push	r17
     388:	cf 93       	push	r28
     38a:	c8 2f       	mov	r28, r24
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
     38c:	68 2f       	mov	r22, r24
     38e:	61 70       	andi	r22, 0x01	; 1
     390:	08 e8       	ldi	r16, 0x88	; 136
     392:	10 e0       	ldi	r17, 0x00	; 0
     394:	f8 01       	movw	r30, r16
     396:	86 81       	ldd	r24, Z+6	; 0x06
     398:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
     39c:	c1 fb       	bst	r28, 1
     39e:	66 27       	eor	r22, r22
     3a0:	60 f9       	bld	r22, 0
     3a2:	f8 01       	movw	r30, r16
     3a4:	87 81       	ldd	r24, Z+7	; 0x07
     3a6:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
     3aa:	c2 fb       	bst	r28, 2
     3ac:	66 27       	eor	r22, r22
     3ae:	60 f9       	bld	r22, 0
     3b0:	f8 01       	movw	r30, r16
     3b2:	80 85       	ldd	r24, Z+8	; 0x08
     3b4:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
     3b8:	c3 fb       	bst	r28, 3
     3ba:	66 27       	eor	r22, r22
     3bc:	60 f9       	bld	r22, 0
     3be:	f8 01       	movw	r30, r16
     3c0:	81 85       	ldd	r24, Z+9	; 0x09
}
     3c2:	cf 91       	pop	r28
     3c4:	1f 91       	pop	r17
     3c6:	0f 91       	pop	r16
static void lcd_SendLowerNibble(uint8_t dataByte)
{
    GPIO_PinWrite(LCDConfig.D0,util_IsBitSet(dataByte,0));
    GPIO_PinWrite(LCDConfig.D1,util_IsBitSet(dataByte,1));
    GPIO_PinWrite(LCDConfig.D2,util_IsBitSet(dataByte,2));
    GPIO_PinWrite(LCDConfig.D3,util_IsBitSet(dataByte,3));
     3c8:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

000003cc <lcd_SendDataSignals>:
 * Return value    : none

 * description : This functions generates the signals for sending the Data to LCD
**************************************************************************************************/
static void lcd_SendDataSignals(void)
{
     3cc:	cf 93       	push	r28
     3ce:	df 93       	push	r29
     GPIO_PinWrite(LCDConfig.RS,1);
     3d0:	c8 e8       	ldi	r28, 0x88	; 136
     3d2:	d0 e0       	ldi	r29, 0x00	; 0
     3d4:	61 e0       	ldi	r22, 0x01	; 1
     3d6:	8b 81       	ldd	r24, Y+3	; 0x03
     3d8:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.RW,0);
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	8c 81       	ldd	r24, Y+4	; 0x04
     3e0:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     GPIO_PinWrite(LCDConfig.EN,1);
     3e4:	61 e0       	ldi	r22, 0x01	; 1
     3e6:	8d 81       	ldd	r24, Y+5	; 0x05
     3e8:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
     DELAY_us(10);
     3ec:	8a e0       	ldi	r24, 0x0A	; 10
     3ee:	90 e0       	ldi	r25, 0x00	; 0
     3f0:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
     GPIO_PinWrite(LCDConfig.EN,0);
     3f4:	60 e0       	ldi	r22, 0x00	; 0
     3f6:	8d 81       	ldd	r24, Y+5	; 0x05
}
     3f8:	df 91       	pop	r29
     3fa:	cf 91       	pop	r28
{
     GPIO_PinWrite(LCDConfig.RS,1);
     GPIO_PinWrite(LCDConfig.RW,0);
     GPIO_PinWrite(LCDConfig.EN,1);
     DELAY_us(10);
     GPIO_PinWrite(LCDConfig.EN,0);
     3fc:	0c 94 cf 00 	jmp	0x19e	; 0x19e <GPIO_PinWrite>

00000400 <lcd_BusyCheck>:
 * description : This functions is used check whether LCD is busy.
                 It waits till the LCD is busy by polling the LCD busy flag.
                 After completing the previous operation, LCDs clears its internal busy flag.
**************************************************************************************************/
static void lcd_BusyCheck(void)
{
     400:	cf 93       	push	r28
    uint8_t busyflag;
 
  if(LCDConfig.RW != P_NC)                         //Perform Busy check if RW pin is used
     402:	80 91 8c 00 	lds	r24, 0x008C
     406:	8f 3f       	cpi	r24, 0xFF	; 255
     408:	09 f4       	brne	.+2      	; 0x40c <lcd_BusyCheck+0xc>
     40a:	44 c0       	rjmp	.+136    	; 0x494 <lcd_BusyCheck+0x94>
   {
    GPIO_PinDirection(LCDConfig.D7,INPUT); // Configure busy pin as input
     40c:	60 e0       	ldi	r22, 0x00	; 0
     40e:	80 91 95 00 	lds	r24, 0x0095
     412:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinWrite(LCDConfig.RS,0);           // Select the Command Register by pulling RS LOW
     416:	60 e0       	ldi	r22, 0x00	; 0
     418:	80 91 8b 00 	lds	r24, 0x008B
     41c:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    GPIO_PinWrite(LCDConfig.RW,1);           // Select the Read Operation for busy flag by setting RW
     420:	61 e0       	ldi	r22, 0x01	; 1
     422:	80 91 8c 00 	lds	r24, 0x008C
     426:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
    do
    {

        GPIO_PinWrite(LCDConfig.EN,0);
     42a:	60 e0       	ldi	r22, 0x00	; 0
     42c:	80 91 8d 00 	lds	r24, 0x008D
     430:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
     434:	8a e0       	ldi	r24, 0x0A	; 10
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        GPIO_PinWrite(LCDConfig.EN,1); 
     43c:	61 e0       	ldi	r22, 0x01	; 1
     43e:	80 91 8d 00 	lds	r24, 0x008D
     442:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
        DELAY_us(10);
     446:	8a e0       	ldi	r24, 0x0A	; 10
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        busyflag = GPIO_PinRead(LCDConfig.D7);
     44e:	80 91 95 00 	lds	r24, 0x0095
     452:	0e 94 41 01 	call	0x282	; 0x282 <GPIO_PinRead>
     456:	c8 2f       	mov	r28, r24


        if(LCDConfig.v_LcdMode_U8 == 4)
     458:	80 91 8a 00 	lds	r24, 0x008A
     45c:	84 30       	cpi	r24, 0x04	; 4
     45e:	91 f4       	brne	.+36     	; 0x484 <lcd_BusyCheck+0x84>
        {
            /* Perform extra dummy read for 4-bit */            
            GPIO_PinWrite(LCDConfig.EN,0);
     460:	60 e0       	ldi	r22, 0x00	; 0
     462:	80 91 8d 00 	lds	r24, 0x008D
     466:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
     46a:	8a e0       	ldi	r24, 0x0A	; 10
     46c:	90 e0       	ldi	r25, 0x00	; 0
     46e:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
            GPIO_PinWrite(LCDConfig.EN,1); 
     472:	61 e0       	ldi	r22, 0x01	; 1
     474:	80 91 8d 00 	lds	r24, 0x008D
     478:	0e 94 cf 00 	call	0x19e	; 0x19e <GPIO_PinWrite>
            DELAY_us(10);
     47c:	8a e0       	ldi	r24, 0x0A	; 10
     47e:	90 e0       	ldi	r25, 0x00	; 0
     480:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        }    
    }while(busyflag!=0);
     484:	c1 11       	cpse	r28, r1
     486:	d1 cf       	rjmp	.-94     	; 0x42a <lcd_BusyCheck+0x2a>

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
     488:	61 e0       	ldi	r22, 0x01	; 1
     48a:	80 91 95 00 	lds	r24, 0x0095
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
 }
}
     48e:	cf 91       	pop	r28
            GPIO_PinWrite(LCDConfig.EN,1); 
            DELAY_us(10);
        }    
    }while(busyflag!=0);

    GPIO_PinDirection(LCDConfig.D7,OUTPUT); // Configure busy pin as Output
     490:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
     494:	81 e0       	ldi	r24, 0x01	; 1
     496:	90 e0       	ldi	r25, 0x00	; 0
 }
}
     498:	cf 91       	pop	r28
  }
else
 {
    /* Busy flag cannot be read as RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
     49a:	0c 94 52 00 	jmp	0xa4	; 0xa4 <DELAY_ms>

0000049e <LCD_SetUp>:
               gpioPins_et D3,
               gpioPins_et D4,
               gpioPins_et D5,
               gpioPins_et D6,
               gpioPins_et D7 )
{
     49e:	8f 92       	push	r8
     4a0:	9f 92       	push	r9
     4a2:	af 92       	push	r10
     4a4:	bf 92       	push	r11
     4a6:	cf 92       	push	r12
     4a8:	df 92       	push	r13
     4aa:	ef 92       	push	r14
     4ac:	ff 92       	push	r15
     4ae:	0f 93       	push	r16
     4b0:	1f 93       	push	r17
     4b2:	cf 93       	push	r28
     4b4:	df 93       	push	r29
     4b6:	cd b7       	in	r28, 0x3d	; 61
     4b8:	de b7       	in	r29, 0x3e	; 62
     4ba:	98 2e       	mov	r9, r24
     4bc:	b6 2e       	mov	r11, r22
     4be:	d4 2e       	mov	r13, r20
     4c0:	ff 84       	ldd	r15, Y+15	; 0x0f
     4c2:	18 89       	ldd	r17, Y+16	; 0x10
  /* Copy the PIN numbers where the LCD is connected */
    LCDConfig.RS = RS;
     4c4:	80 93 8b 00 	sts	0x008B, r24
    LCDConfig.RW = RW;
     4c8:	60 93 8c 00 	sts	0x008C, r22
    LCDConfig.EN = EN;
     4cc:	40 93 8d 00 	sts	0x008D, r20

    LCDConfig.D0 = D0;
     4d0:	20 93 8e 00 	sts	0x008E, r18
    LCDConfig.D1 = D1;
     4d4:	00 93 8f 00 	sts	0x008F, r16
    LCDConfig.D2 = D2;
     4d8:	e0 92 90 00 	sts	0x0090, r14
    LCDConfig.D3 = D3;
     4dc:	c0 92 91 00 	sts	0x0091, r12
    LCDConfig.D4 = D4;
     4e0:	a0 92 92 00 	sts	0x0092, r10
    LCDConfig.D5 = D5;
     4e4:	80 92 93 00 	sts	0x0093, r8
    LCDConfig.D6 = D6;
     4e8:	f0 92 94 00 	sts	0x0094, r15
    LCDConfig.D7 = D7;
     4ec:	10 93 95 00 	sts	0x0095, r17


    if((D0 == P_NC) || (D1 == P_NC) || (D2 == P_NC) || (D3 == P_NC))
     4f0:	2f 3f       	cpi	r18, 0xFF	; 255
     4f2:	39 f0       	breq	.+14     	; 0x502 <LCD_SetUp+0x64>
     4f4:	0f 3f       	cpi	r16, 0xFF	; 255
     4f6:	29 f0       	breq	.+10     	; 0x502 <LCD_SetUp+0x64>
     4f8:	8f ef       	ldi	r24, 0xFF	; 255
     4fa:	e8 16       	cp	r14, r24
     4fc:	11 f0       	breq	.+4      	; 0x502 <LCD_SetUp+0x64>
     4fe:	c8 12       	cpse	r12, r24
     500:	04 c0       	rjmp	.+8      	; 0x50a <LCD_SetUp+0x6c>
    {
        LCDConfig.v_LcdMode_U8 = 4; // Select 4-bit mode as D0-D3 are not used(P_NC)
     502:	84 e0       	ldi	r24, 0x04	; 4
     504:	80 93 8a 00 	sts	0x008A, r24
     508:	13 c0       	rjmp	.+38     	; 0x530 <LCD_SetUp+0x92>
    }
    else
    {
        LCDConfig.v_LcdMode_U8 = 8; // 8-bit mode configure D0-D3 as output.      
     50a:	88 e0       	ldi	r24, 0x08	; 8
     50c:	80 93 8a 00 	sts	0x008A, r24
        GPIO_PinDirection(D0,OUTPUT);
     510:	61 e0       	ldi	r22, 0x01	; 1
     512:	82 2f       	mov	r24, r18
     514:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D1,OUTPUT);
     518:	61 e0       	ldi	r22, 0x01	; 1
     51a:	80 2f       	mov	r24, r16
     51c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D2,OUTPUT);
     520:	61 e0       	ldi	r22, 0x01	; 1
     522:	8e 2d       	mov	r24, r14
     524:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
        GPIO_PinDirection(D3,OUTPUT);
     528:	61 e0       	ldi	r22, 0x01	; 1
     52a:	8c 2d       	mov	r24, r12
     52c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    }

    /* Configure RS,RW,EN, D4-D7 as Output for both 4/8-bit mode.*/
    GPIO_PinDirection(RS,OUTPUT);
     530:	61 e0       	ldi	r22, 0x01	; 1
     532:	89 2d       	mov	r24, r9
     534:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(RW,OUTPUT);
     538:	61 e0       	ldi	r22, 0x01	; 1
     53a:	8b 2d       	mov	r24, r11
     53c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(EN,OUTPUT);
     540:	61 e0       	ldi	r22, 0x01	; 1
     542:	8d 2d       	mov	r24, r13
     544:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>

    GPIO_PinDirection(D4,OUTPUT);
     548:	61 e0       	ldi	r22, 0x01	; 1
     54a:	8a 2d       	mov	r24, r10
     54c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D5,OUTPUT);
     550:	61 e0       	ldi	r22, 0x01	; 1
     552:	88 2d       	mov	r24, r8
     554:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D6,OUTPUT);
     558:	61 e0       	ldi	r22, 0x01	; 1
     55a:	8f 2d       	mov	r24, r15
     55c:	0e 94 5d 00 	call	0xba	; 0xba <GPIO_PinDirection>
    GPIO_PinDirection(D7,OUTPUT);  
     560:	61 e0       	ldi	r22, 0x01	; 1
     562:	81 2f       	mov	r24, r17
}
     564:	df 91       	pop	r29
     566:	cf 91       	pop	r28
     568:	1f 91       	pop	r17
     56a:	0f 91       	pop	r16
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	bf 90       	pop	r11
     576:	af 90       	pop	r10
     578:	9f 90       	pop	r9
     57a:	8f 90       	pop	r8
    GPIO_PinDirection(EN,OUTPUT);

    GPIO_PinDirection(D4,OUTPUT);
    GPIO_PinDirection(D5,OUTPUT);
    GPIO_PinDirection(D6,OUTPUT);
    GPIO_PinDirection(D7,OUTPUT);  
     57c:	0c 94 5d 00 	jmp	0xba	; 0xba <GPIO_PinDirection>

00000580 <LCD_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.                
                The behaviour is undefined if unsupported commands are sent.    
****************************************************************************************************/
void LCD_CmdWrite( uint8_t v_lcdCmd_u8)
{
     580:	cf 93       	push	r28
     582:	c8 2f       	mov	r28, r24
    lcd_BusyCheck();
     584:	0e 94 00 02 	call	0x400	; 0x400 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     588:	80 91 8a 00 	lds	r24, 0x008A
     58c:	88 30       	cpi	r24, 0x08	; 8
     58e:	21 f4       	brne	.+8      	; 0x598 <LCD_CmdWrite+0x18>
     {
         lcd_SendLowerNibble(v_lcdCmd_u8);
     590:	8c 2f       	mov	r24, r28
     592:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendLowerNibble>
     596:	07 c0       	rjmp	.+14     	; 0x5a6 <LCD_CmdWrite+0x26>
     }
     else
     {
         lcd_SendHigherNibble(v_lcdCmd_u8);
     598:	8c 2f       	mov	r24, r28
     59a:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
         lcd_SendCmdSignals();
     59e:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     5a2:	c2 95       	swap	r28
     5a4:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     5a6:	8c 2f       	mov	r24, r28
     5a8:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
     lcd_SendCmdSignals();
}
     5ac:	cf 91       	pop	r28
         lcd_SendCmdSignals();
         v_lcdCmd_u8 = v_lcdCmd_u8 << 4;
     }

     lcd_SendHigherNibble(v_lcdCmd_u8);
     lcd_SendCmdSignals();
     5ae:	0c 94 a8 01 	jmp	0x350	; 0x350 <lcd_SendCmdSignals>

000005b2 <LCD_GoToLine>:
           C_LcdLineThree,

****************************************************************************************************/
void LCD_GoToLine(uint8_t v_lineNumber_u8)
{
    if(v_lineNumber_u8 < LCDConfig.v_MaxSupportedLines_U8)
     5b2:	90 91 88 00 	lds	r25, 0x0088
     5b6:	89 17       	cp	r24, r25
     5b8:	58 f4       	brcc	.+22     	; 0x5d0 <LCD_GoToLine+0x1e>
    {
        /* If the line number is within range then
           Move the Cursor to beginning of the specified line */
        v_LcdTrackCursorPos_U8 = 0x00;
     5ba:	10 92 96 00 	sts	0x0096, r1
        v_LcdTrackLineNum_U8 = v_lineNumber_u8;
     5be:	80 93 97 00 	sts	0x0097, r24
        LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_lineNumber_u8]);
     5c2:	e8 2f       	mov	r30, r24
     5c4:	f0 e0       	ldi	r31, 0x00	; 0
     5c6:	e0 5a       	subi	r30, 0xA0	; 160
     5c8:	ff 4f       	sbci	r31, 0xFF	; 255
     5ca:	80 81       	ld	r24, Z
     5cc:	0c 94 c0 02 	jmp	0x580	; 0x580 <LCD_CmdWrite>
     5d0:	08 95       	ret

000005d2 <LCD_Clear>:

 * description  :This function clears the LCD and moves the cursor to beginning of first line
****************************************************************************************************/
void LCD_Clear()
{
    LCD_CmdWrite(CMD_LCD_CLEAR);    // Clear the LCD and go to First line First Position
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	0e 94 c0 02 	call	0x580	; 0x580 <LCD_CmdWrite>
    LCD_GoToLine(C_LcdLineZero);
     5d8:	80 e0       	ldi	r24, 0x00	; 0
     5da:	0c 94 d9 02 	jmp	0x5b2	; 0x5b2 <LCD_GoToLine>

000005de <LCD_Init>:
**************************************************************************************************/
void LCD_Init(uint8_t v_lcdNoOfLines_u8, uint8_t v_MaxCharsPerLine_u8)
{


    LCDConfig.v_MaxSupportedChars_U8 = v_MaxCharsPerLine_u8; //Maintaian the LCD type
     5de:	60 93 89 00 	sts	0x0089, r22
    LCDConfig.v_MaxSupportedLines_U8 = v_lcdNoOfLines_u8;
     5e2:	80 93 88 00 	sts	0x0088, r24
    if(v_lcdNoOfLines_u8 > C_LcdLineTwo)
     5e6:	83 30       	cpi	r24, 0x03	; 3
     5e8:	40 f0       	brcs	.+16     	; 0x5fa <LCD_Init+0x1c>
    {
        ARR_LcdLineNumAddress_U8[C_LcdLineTwo] =  0x90 + (v_MaxCharsPerLine_u8 & 0x0fu);
     5ea:	6f 70       	andi	r22, 0x0F	; 15
     5ec:	80 e9       	ldi	r24, 0x90	; 144
     5ee:	86 0f       	add	r24, r22
     5f0:	80 93 62 00 	sts	0x0062, r24
        ARR_LcdLineNumAddress_U8[C_LcdLineThree] =  0xd0 + (v_MaxCharsPerLine_u8 & 0x0fu);
     5f4:	60 53       	subi	r22, 0x30	; 48
     5f6:	60 93 63 00 	sts	0x0063, r22
    }

    DELAY_ms(100);
     5fa:	84 e6       	ldi	r24, 0x64	; 100
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>

    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     602:	80 91 8a 00 	lds	r24, 0x008A
     606:	88 30       	cpi	r24, 0x08	; 8
     608:	11 f4       	brne	.+4      	; 0x60e <LCD_Init+0x30>
    {
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
     60a:	88 e3       	ldi	r24, 0x38	; 56
     60c:	27 c0       	rjmp	.+78     	; 0x65c <LCD_Init+0x7e>
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
     60e:	84 30       	cpi	r24, 0x04	; 4
     610:	39 f5       	brne	.+78     	; 0x660 <LCD_Init+0x82>
                 This is used only in 4-bit mode as the LCD by default boots in 8-Bit mode.
----------------------------------------------------------------------------------*/
static void lcd_Reset(void)
{
    /* LCD reset sequence for 4-bit mode, refer data sheet for more info */
    lcd_SendHigherNibble(0x30);
     612:	80 e3       	ldi	r24, 0x30	; 48
     614:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     618:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
    DELAY_ms(100);
     61c:	84 e6       	ldi	r24, 0x64	; 100
     61e:	90 e0       	ldi	r25, 0x00	; 0
     620:	0e 94 52 00 	call	0xa4	; 0xa4 <DELAY_ms>
    lcd_SendHigherNibble(0x30);
     624:	80 e3       	ldi	r24, 0x30	; 48
     626:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     62a:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
    DELAY_us(200);
     62e:	88 ec       	ldi	r24, 0xC8	; 200
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x30);
     636:	80 e3       	ldi	r24, 0x30	; 48
     638:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     63c:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
    DELAY_us(200);
     640:	88 ec       	ldi	r24, 0xC8	; 200
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
    lcd_SendHigherNibble(0x20);
     648:	80 e2       	ldi	r24, 0x20	; 32
     64a:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
    lcd_SendCmdSignals();
     64e:	0e 94 a8 01 	call	0x350	; 0x350 <lcd_SendCmdSignals>
    DELAY_us(200);
     652:	88 ec       	ldi	r24, 0xC8	; 200
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	0e 94 49 00 	call	0x92	; 0x92 <DELAY_us>
        LCD_CmdWrite(CMD_LCD_EIGHT_BIT_MODE); // Initialize the LCD for 8-bit 5x7 matrix type
    }
    else if(LCDConfig.v_LcdMode_U8 == C_FourBitMode_U8)
    {
        lcd_Reset();
        LCD_CmdWrite(CMD_LCD_FOUR_BIT_MODE); // Initialize the LCD for 4-bit 5x7 matrix type 
     65a:	88 e2       	ldi	r24, 0x28	; 40
     65c:	0e 94 c0 02 	call	0x580	; 0x580 <LCD_CmdWrite>
    }

    LCD_CmdWrite(CMD_DISPLAY_ON_CURSOR_ON);     // Display ON cursor ON
     660:	8e e0       	ldi	r24, 0x0E	; 14
     662:	0e 94 c0 02 	call	0x580	; 0x580 <LCD_CmdWrite>
    LCD_Clear();                             // Clear the LCD and go to First line First Position
     666:	0c 94 e9 02 	jmp	0x5d2	; 0x5d2 <LCD_Clear>

0000066a <LCD_GoToNextLine>:
****************************************************************************************************/
void  LCD_GoToNextLine(void)
{
    /*Increment the current line number.
      In case it exceeds the limit, rool it back to first line */
    v_LcdTrackLineNum_U8++;
     66a:	80 91 97 00 	lds	r24, 0x0097
     66e:	8f 5f       	subi	r24, 0xFF	; 255
     670:	80 93 97 00 	sts	0x0097, r24
    v_LcdTrackCursorPos_U8 = 0x00;
     674:	10 92 96 00 	sts	0x0096, r1
    if(v_LcdTrackLineNum_U8 >= LCDConfig.v_MaxSupportedLines_U8)
     678:	90 91 88 00 	lds	r25, 0x0088
     67c:	89 17       	cp	r24, r25
     67e:	10 f0       	brcs	.+4      	; 0x684 <LCD_GoToNextLine+0x1a>
        v_LcdTrackLineNum_U8 = C_LcdLineZero;
     680:	10 92 97 00 	sts	0x0097, r1
    LCD_CmdWrite(ARR_LcdLineNumAddress_U8[v_LcdTrackLineNum_U8]);
     684:	e0 91 97 00 	lds	r30, 0x0097
     688:	f0 e0       	ldi	r31, 0x00	; 0
     68a:	e0 5a       	subi	r30, 0xA0	; 160
     68c:	ff 4f       	sbci	r31, 0xFF	; 255
     68e:	80 81       	ld	r24, Z
     690:	0c 94 c0 02 	jmp	0x580	; 0x580 <LCD_CmdWrite>

00000694 <LCD_DisplayChar>:
 * description  : This function sends a character to be displayed on LCD.
                  Any valid ascii value can be passed to display respective character

****************************************************************************************************/
void LCD_DisplayChar(char v_lcdData_u8)
{
     694:	cf 93       	push	r28
     696:	c8 2f       	mov	r28, r24
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
     698:	90 91 96 00 	lds	r25, 0x0096
     69c:	80 91 89 00 	lds	r24, 0x0089
     6a0:	98 17       	cp	r25, r24
     6a2:	60 f4       	brcc	.+24     	; 0x6bc <LCD_DisplayChar+0x28>
     6a4:	ca 30       	cpi	r28, 0x0A	; 10
     6a6:	51 f0       	breq	.+20     	; 0x6bc <LCD_DisplayChar+0x28>

 * description : This functions is used to send a byte of data to LCD.                 .    
**************************************************************************************************/
static void lcd_DataWrite( uint8_t dataByte)
{
    lcd_BusyCheck();
     6a8:	0e 94 00 02 	call	0x400	; 0x400 <lcd_BusyCheck>
    if(LCDConfig.v_LcdMode_U8 == C_EightBitMode_U8)
     6ac:	80 91 8a 00 	lds	r24, 0x008A
     6b0:	88 30       	cpi	r24, 0x08	; 8
     6b2:	49 f4       	brne	.+18     	; 0x6c6 <LCD_DisplayChar+0x32>
     {
         lcd_SendLowerNibble(dataByte);
     6b4:	8c 2f       	mov	r24, r28
     6b6:	0e 94 c2 01 	call	0x384	; 0x384 <lcd_SendLowerNibble>
     6ba:	0c c0       	rjmp	.+24     	; 0x6d4 <LCD_DisplayChar+0x40>
{
    if((v_LcdTrackCursorPos_U8>=LCDConfig.v_MaxSupportedChars_U8) || (v_lcdData_u8=='\n'))
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        LCD_GoToNextLine();
     6bc:	0e 94 35 03 	call	0x66a	; 0x66a <LCD_GoToNextLine>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
     6c0:	ca 30       	cpi	r28, 0x0A	; 10
     6c2:	91 f0       	breq	.+36     	; 0x6e8 <LCD_DisplayChar+0x54>
     6c4:	f1 cf       	rjmp	.-30     	; 0x6a8 <LCD_DisplayChar+0x14>
     {
         lcd_SendLowerNibble(dataByte);
     }
     else
     {
         lcd_SendHigherNibble(dataByte);
     6c6:	8c 2f       	mov	r24, r28
     6c8:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
         lcd_SendDataSignals();
     6cc:	0e 94 e6 01 	call	0x3cc	; 0x3cc <lcd_SendDataSignals>
         dataByte = dataByte << 4;
     6d0:	c2 95       	swap	r28
     6d2:	c0 7f       	andi	r28, 0xF0	; 240
     }

     lcd_SendHigherNibble(dataByte);
     6d4:	8c 2f       	mov	r24, r28
     6d6:	0e 94 82 01 	call	0x304	; 0x304 <lcd_SendHigherNibble>
     lcd_SendDataSignals();
     6da:	0e 94 e6 01 	call	0x3cc	; 0x3cc <lcd_SendDataSignals>
    }
    if(v_lcdData_u8!='\n') /* Display the character if its not newLine Char */
    {

        lcd_DataWrite(v_lcdData_u8); /* Display the data and keep track of cursor */
        v_LcdTrackCursorPos_U8++;
     6de:	80 91 96 00 	lds	r24, 0x0096
     6e2:	8f 5f       	subi	r24, 0xFF	; 255
     6e4:	80 93 96 00 	sts	0x0096, r24
    }
}
     6e8:	cf 91       	pop	r28
     6ea:	08 95       	ret

000006ec <LCD_DisplayNumber.part.3>:
    Hex:        7.(16,0x12AB,3) then 3-digits ie. 2AB will be displayed
                8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
                9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.                
****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8)
     6ec:	af 92       	push	r10
     6ee:	bf 92       	push	r11
     6f0:	cf 92       	push	r12
     6f2:	df 92       	push	r13
     6f4:	ef 92       	push	r14
     6f6:	ff 92       	push	r15
     6f8:	0f 93       	push	r16
     6fa:	1f 93       	push	r17
     6fc:	cf 93       	push	r28
     6fe:	df 93       	push	r29
     700:	1f 92       	push	r1
     702:	cd b7       	in	r28, 0x3d	; 61
     704:	de b7       	in	r29, 0x3e	; 62
     706:	6b 01       	movw	r12, r22
     708:	7c 01       	movw	r14, r24
    {
        while(v_numOfDigitsToDisplay_u8!=0)
        {
          /* Start Extracting the bits from the specified bit positions.
          Get the Acsii values of the bits and display */
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
     70a:	aa 24       	eor	r10, r10
     70c:	a3 94       	inc	r10
     70e:	b1 2c       	mov	r11, r1
{
    uint8_t i=0,a[10];
    
    if(C_BINARY_U8 == v_numericSystem_u8)
    {
        while(v_numOfDigitsToDisplay_u8!=0)
     710:	44 23       	and	r20, r20
     712:	e9 f0       	breq	.+58     	; 0x74e <LCD_DisplayNumber.part.3+0x62>
        {
          /* Start Extracting the bits from the specified bit positions.
          Get the Acsii values of the bits and display */
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
     714:	8f ef       	ldi	r24, 0xFF	; 255
     716:	84 0f       	add	r24, r20
     718:	85 01       	movw	r16, r10
     71a:	02 c0       	rjmp	.+4      	; 0x720 <LCD_DisplayNumber.part.3+0x34>
     71c:	00 0f       	add	r16, r16
     71e:	11 1f       	adc	r17, r17
     720:	8a 95       	dec	r24
     722:	e2 f7       	brpl	.-8      	; 0x71c <LCD_DisplayNumber.part.3+0x30>
     724:	01 2e       	mov	r0, r17
     726:	00 0c       	add	r0, r0
     728:	22 0b       	sbc	r18, r18
     72a:	33 0b       	sbc	r19, r19
     72c:	0c 21       	and	r16, r12
     72e:	1d 21       	and	r17, r13
     730:	2e 21       	and	r18, r14
     732:	3f 21       	and	r19, r15
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	01 2b       	or	r16, r17
     738:	02 2b       	or	r16, r18
     73a:	03 2b       	or	r16, r19
     73c:	09 f4       	brne	.+2      	; 0x740 <LCD_DisplayNumber.part.3+0x54>
     73e:	80 e0       	ldi	r24, 0x00	; 0
          LCD_DisplayChar(util_Dec2Ascii(i));
     740:	80 5d       	subi	r24, 0xD0	; 208
     742:	49 83       	std	Y+1, r20	; 0x01
     744:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
          v_numOfDigitsToDisplay_u8--;
     748:	49 81       	ldd	r20, Y+1	; 0x01
     74a:	41 50       	subi	r20, 0x01	; 1
     74c:	e1 cf       	rjmp	.-62     	; 0x710 <LCD_DisplayNumber.part.3+0x24>
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
     74e:	0f 90       	pop	r0
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	1f 91       	pop	r17
     756:	0f 91       	pop	r16
     758:	ff 90       	pop	r15
     75a:	ef 90       	pop	r14
     75c:	df 90       	pop	r13
     75e:	cf 90       	pop	r12
     760:	bf 90       	pop	r11
     762:	af 90       	pop	r10
     764:	08 95       	ret

00000766 <LCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

****************************************************************************************************/
#if (Enable_LCD_DisplayString==1)
void LCD_DisplayString(const char *ptr_stringPointer_u8)
{
     766:	cf 93       	push	r28
     768:	df 93       	push	r29
     76a:	ec 01       	movw	r28, r24
    while((*ptr_stringPointer_u8)!=0)
     76c:	89 91       	ld	r24, Y+
     76e:	88 23       	and	r24, r24
     770:	19 f0       	breq	.+6      	; 0x778 <LCD_DisplayString+0x12>
        LCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
     772:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     776:	fa cf       	rjmp	.-12     	; 0x76c <LCD_DisplayString+0x6>
}
     778:	df 91       	pop	r29
     77a:	cf 91       	pop	r28
     77c:	08 95       	ret

0000077e <LCD_DisplayNumber>:
                8.(C_HEX_U8,0x12AB,6) then 6-digits ie. 0012AB will be displayed
                9.(C_HEX_U8,0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.                
****************************************************************************************************/
#if ((Enable_LCD_DisplayNumber == 1) || (Enable_LCD_DisplayFloatNumber == 1) || (Enable_LCD_Printf==1))
void LCD_DisplayNumber(uint8_t v_numericSystem_u8, uint32_t v_number_u32, uint8_t v_numOfDigitsToDisplay_u8)
{
     77e:	4f 92       	push	r4
     780:	5f 92       	push	r5
     782:	6f 92       	push	r6
     784:	7f 92       	push	r7
     786:	bf 92       	push	r11
     788:	cf 92       	push	r12
     78a:	df 92       	push	r13
     78c:	ef 92       	push	r14
     78e:	ff 92       	push	r15
     790:	0f 93       	push	r16
     792:	1f 93       	push	r17
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	cd b7       	in	r28, 0x3d	; 61
     79a:	de b7       	in	r29, 0x3e	; 62
     79c:	2a 97       	sbiw	r28, 0x0a	; 10
     79e:	0f b6       	in	r0, 0x3f	; 63
     7a0:	f8 94       	cli
     7a2:	de bf       	out	0x3e, r29	; 62
     7a4:	0f be       	out	0x3f, r0	; 63
     7a6:	cd bf       	out	0x3d, r28	; 61
     7a8:	b8 2e       	mov	r11, r24
     7aa:	cb 01       	movw	r24, r22
     7ac:	ba 01       	movw	r22, r20
     7ae:	02 2f       	mov	r16, r18
    uint8_t i=0,a[10];
    
    if(C_BINARY_U8 == v_numericSystem_u8)
     7b0:	22 e0       	ldi	r18, 0x02	; 2
     7b2:	b2 12       	cpse	r11, r18
     7b4:	16 c0       	rjmp	.+44     	; 0x7e2 <LCD_DisplayNumber+0x64>
     7b6:	40 2f       	mov	r20, r16
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
     7b8:	2a 96       	adiw	r28, 0x0a	; 10
     7ba:	0f b6       	in	r0, 0x3f	; 63
     7bc:	f8 94       	cli
     7be:	de bf       	out	0x3e, r29	; 62
     7c0:	0f be       	out	0x3f, r0	; 63
     7c2:	cd bf       	out	0x3d, r28	; 61
     7c4:	df 91       	pop	r29
     7c6:	cf 91       	pop	r28
     7c8:	1f 91       	pop	r17
     7ca:	0f 91       	pop	r16
     7cc:	ff 90       	pop	r15
     7ce:	ef 90       	pop	r14
     7d0:	df 90       	pop	r13
     7d2:	cf 90       	pop	r12
     7d4:	bf 90       	pop	r11
     7d6:	7f 90       	pop	r7
     7d8:	6f 90       	pop	r6
     7da:	5f 90       	pop	r5
     7dc:	4f 90       	pop	r4
     7de:	0c 94 76 03 	jmp	0x6ec	; 0x6ec <LCD_DisplayNumber.part.3>
          i = util_GetBitStatus(v_number_u32,(v_numOfDigitsToDisplay_u8-1));
          LCD_DisplayChar(util_Dec2Ascii(i));
          v_numOfDigitsToDisplay_u8--;
        }        
    }    
    else if(v_number_u32==0)
     7e2:	61 15       	cp	r22, r1
     7e4:	71 05       	cpc	r23, r1
     7e6:	81 05       	cpc	r24, r1
     7e8:	91 05       	cpc	r25, r1
     7ea:	49 f0       	breq	.+18     	; 0x7fe <LCD_DisplayNumber+0x80>
     7ec:	fe 01       	movw	r30, r28
     7ee:	31 96       	adiw	r30, 0x01	; 1
     7f0:	6f 01       	movw	r12, r30
     7f2:	7f 01       	movw	r14, r30
                First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                
                example for Decimal number: 
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
     7f4:	4b 2c       	mov	r4, r11
     7f6:	51 2c       	mov	r5, r1
     7f8:	61 2c       	mov	r6, r1
     7fa:	71 2c       	mov	r7, r1
     7fc:	2a c0       	rjmp	.+84     	; 0x852 <LCD_DisplayNumber+0xd4>
    else if(v_number_u32==0)
    {
        /* If the number is zero then display Specified number of zeros*/
        /*TODO: Display single zero or multiple. Currently single zero is displayed*/
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
     7fe:	80 e3       	ldi	r24, 0x30	; 48
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
          i--;
        }
    }
}
     800:	2a 96       	adiw	r28, 0x0a	; 10
     802:	0f b6       	in	r0, 0x3f	; 63
     804:	f8 94       	cli
     806:	de bf       	out	0x3e, r29	; 62
     808:	0f be       	out	0x3f, r0	; 63
     80a:	cd bf       	out	0x3d, r28	; 61
     80c:	df 91       	pop	r29
     80e:	cf 91       	pop	r28
     810:	1f 91       	pop	r17
     812:	0f 91       	pop	r16
     814:	ff 90       	pop	r15
     816:	ef 90       	pop	r14
     818:	df 90       	pop	r13
     81a:	cf 90       	pop	r12
     81c:	bf 90       	pop	r11
     81e:	7f 90       	pop	r7
     820:	6f 90       	pop	r6
     822:	5f 90       	pop	r5
     824:	4f 90       	pop	r4
    else if(v_number_u32==0)
    {
        /* If the number is zero then display Specified number of zeros*/
        /*TODO: Display single zero or multiple. Currently single zero is displayed*/
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
     826:	0c 94 4a 03 	jmp	0x694	; 0x694 <LCD_DisplayChar>
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
        {
            /* Continue extracting the digits from right side
               till the Specified v_numOfDigitsToDisplay_u8 */
            if(v_number_u32!=0)
     82a:	61 15       	cp	r22, r1
     82c:	71 05       	cpc	r23, r1
     82e:	81 05       	cpc	r24, r1
     830:	91 05       	cpc	r25, r1
     832:	a1 f0       	breq	.+40     	; 0x85c <LCD_DisplayNumber+0xde>
                First get the remainder and divide the number by TypeOfNum(10-Dec, 16-Hex) each time.
                
                example for Decimal number: 
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
     834:	16 2f       	mov	r17, r22
     836:	a3 01       	movw	r20, r6
     838:	92 01       	movw	r18, r4
     83a:	0e 94 33 08 	call	0x1066	; 0x1066 <__udivmodsi4>
     83e:	ca 01       	movw	r24, r20
     840:	b9 01       	movw	r22, r18
     842:	b2 9e       	mul	r11, r18
     844:	10 19       	sub	r17, r0
     846:	11 24       	eor	r1, r1
     848:	f7 01       	movw	r30, r14
     84a:	10 83       	st	Z, r17
     84c:	ff ef       	ldi	r31, 0xFF	; 255
     84e:	ef 1a       	sub	r14, r31
     850:	ff 0a       	sbc	r15, r31
     852:	1e 2d       	mov	r17, r14
     854:	1c 19       	sub	r17, r12
        //for(i=0;((i<v_numOfDigitsToDisplay_u8) && (i<C_MaxDigitsToDisplay_U8));i++)
            LCD_DisplayChar('0');
    }
    else
    {
        for(i=0;i<v_numOfDigitsToDisplay_u8;i++)
     856:	10 17       	cp	r17, r16
     858:	40 f3       	brcs	.-48     	; 0x82a <LCD_DisplayNumber+0xac>
     85a:	0f c0       	rjmp	.+30     	; 0x87a <__stack+0x1b>
                If v_number_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(v_number_u32,v_numericSystem_u8);
                v_number_u32=v_number_u32/v_numericSystem_u8;
            }
            else if( (v_numOfDigitsToDisplay_u8 == C_DisplayDefaultDigits_U8) ||
     85c:	0b 30       	cpi	r16, 0x0B	; 11
     85e:	68 f4       	brcc	.+26     	; 0x87a <__stack+0x1b>
            else
            {
                /* In case user expects more digits to be displayed than the actual digits in number,
                  then update the remaining digits with zero.
               Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
     860:	f7 01       	movw	r30, r14
     862:	10 82       	st	Z, r1
     864:	f3 cf       	rjmp	.-26     	; 0x84c <LCD_DisplayNumber+0xce>
        }
        
         while(i!=0)
        { 
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
     866:	fe 01       	movw	r30, r28
     868:	e1 0f       	add	r30, r17
     86a:	f1 1d       	adc	r31, r1
     86c:	80 81       	ld	r24, Z
     86e:	8a 30       	cpi	r24, 0x0A	; 10
     870:	38 f0       	brcs	.+14     	; 0x880 <__stack+0x21>
     872:	89 5c       	subi	r24, 0xC9	; 201
     874:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
          i--;
     878:	11 50       	subi	r17, 0x01	; 1
               Ex: v_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
            }
        }
        
         while(i!=0)
     87a:	11 11       	cpse	r17, r1
     87c:	f4 cf       	rjmp	.-24     	; 0x866 <__stack+0x7>
     87e:	02 c0       	rjmp	.+4      	; 0x884 <__stack+0x25>
        { 
          /* Finally get the ascii values of the digits and display*/
          LCD_DisplayChar(util_Hex2Ascii(a[i-1]));
     880:	80 5d       	subi	r24, 0xD0	; 208
     882:	f8 cf       	rjmp	.-16     	; 0x874 <__stack+0x15>
          i--;
        }
    }
}
     884:	2a 96       	adiw	r28, 0x0a	; 10
     886:	0f b6       	in	r0, 0x3f	; 63
     888:	f8 94       	cli
     88a:	de bf       	out	0x3e, r29	; 62
     88c:	0f be       	out	0x3f, r0	; 63
     88e:	cd bf       	out	0x3d, r28	; 61
     890:	df 91       	pop	r29
     892:	cf 91       	pop	r28
     894:	1f 91       	pop	r17
     896:	0f 91       	pop	r16
     898:	ff 90       	pop	r15
     89a:	ef 90       	pop	r14
     89c:	df 90       	pop	r13
     89e:	cf 90       	pop	r12
     8a0:	bf 90       	pop	r11
     8a2:	7f 90       	pop	r7
     8a4:	6f 90       	pop	r6
     8a6:	5f 90       	pop	r5
     8a8:	4f 90       	pop	r4
     8aa:	08 95       	ret

000008ac <LCD_DisplayFloatNumber>:
    Note: Float will be disabled by default as it takes huge controller resources
         It can be enabled by changing value of Enable_LCD_DisplayFloatNumber to 1 in lcd.h
***************************************************************************************************/
#if (Enable_LCD_DisplayFloatNumber == 1)  
void LCD_DisplayFloatNumber(double v_floatNum_f32)
{
     8ac:	8f 92       	push	r8
     8ae:	9f 92       	push	r9
     8b0:	af 92       	push	r10
     8b2:	bf 92       	push	r11
     8b4:	cf 92       	push	r12
     8b6:	df 92       	push	r13
     8b8:	ef 92       	push	r14
     8ba:	ff 92       	push	r15
     8bc:	6b 01       	movw	r12, r22
     8be:	7c 01       	movw	r14, r24
      1.Type cast the number to int to get the integer part.
      2.Display the extracted integer part followed by a decimal point(.)
      3.Later the integer part is made zero by subtracting with the extracted integer value.
      4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

    v_decNumber_u32 = (uint32_t) v_floatNum_f32;
     8c0:	0e 94 09 07 	call	0xe12	; 0xe12 <__fixunssfsi>
     8c4:	4b 01       	movw	r8, r22
     8c6:	5c 01       	movw	r10, r24
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     8c8:	2f ef       	ldi	r18, 0xFF	; 255
     8ca:	ab 01       	movw	r20, r22
     8cc:	bc 01       	movw	r22, r24
     8ce:	8a e0       	ldi	r24, 0x0A	; 10
     8d0:	0e 94 bf 03 	call	0x77e	; 0x77e <LCD_DisplayNumber>

    LCD_DisplayChar('.');
     8d4:	8e e2       	ldi	r24, 0x2E	; 46
     8d6:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>

    v_floatNum_f32 = v_floatNum_f32 - v_decNumber_u32;
     8da:	c5 01       	movw	r24, r10
     8dc:	b4 01       	movw	r22, r8
     8de:	0e 94 38 07 	call	0xe70	; 0xe70 <__floatunsisf>
     8e2:	9b 01       	movw	r18, r22
     8e4:	ac 01       	movw	r20, r24
     8e6:	c7 01       	movw	r24, r14
     8e8:	b6 01       	movw	r22, r12
     8ea:	0e 94 9c 06 	call	0xd38	; 0xd38 <__subsf3>
    v_decNumber_u32 = v_floatNum_f32 * 1000000;
     8ee:	20 e0       	ldi	r18, 0x00	; 0
     8f0:	34 e2       	ldi	r19, 0x24	; 36
     8f2:	44 e7       	ldi	r20, 0x74	; 116
     8f4:	59 e4       	ldi	r21, 0x49	; 73
     8f6:	0e 94 c6 07 	call	0xf8c	; 0xf8c <__mulsf3>
     8fa:	0e 94 09 07 	call	0xe12	; 0xe12 <__fixunssfsi>
     8fe:	ab 01       	movw	r20, r22
     900:	bc 01       	movw	r22, r24
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     902:	2f ef       	ldi	r18, 0xFF	; 255
     904:	8a e0       	ldi	r24, 0x0A	; 10
}
     906:	ff 90       	pop	r15
     908:	ef 90       	pop	r14
     90a:	df 90       	pop	r13
     90c:	cf 90       	pop	r12
     90e:	bf 90       	pop	r11
     910:	af 90       	pop	r10
     912:	9f 90       	pop	r9
     914:	8f 90       	pop	r8

    LCD_DisplayChar('.');

    v_floatNum_f32 = v_floatNum_f32 - v_decNumber_u32;
    v_decNumber_u32 = v_floatNum_f32 * 1000000;
    LCD_DisplayNumber(C_DECIMAL_U8,v_decNumber_u32,C_DisplayDefaultDigits_U8);
     916:	0c 94 bf 03 	jmp	0x77e	; 0x77e <LCD_DisplayNumber>

0000091a <LCD_Printf>:
        uint8_t v_Num_u8;
        LCD_Printf("num1:%u",(uint16_t)v_Num_u8); 
**************************************************************************************************/
#if ( Enable_LCD_Printf   == 1 ) 
void LCD_Printf(const char *argList, ...)
{
     91a:	cf 92       	push	r12
     91c:	df 92       	push	r13
     91e:	ef 92       	push	r14
     920:	ff 92       	push	r15
     922:	0f 93       	push	r16
     924:	1f 93       	push	r17
     926:	cf 93       	push	r28
     928:	df 93       	push	r29
     92a:	00 d0       	rcall	.+0      	; 0x92c <LCD_Printf+0x12>
     92c:	00 d0       	rcall	.+0      	; 0x92e <LCD_Printf+0x14>
     92e:	1f 92       	push	r1
     930:	cd b7       	in	r28, 0x3d	; 61
     932:	de b7       	in	r29, 0x3e	; 62
     934:	fe 01       	movw	r30, r28
     936:	70 96       	adiw	r30, 0x10	; 16
     938:	c1 90       	ld	r12, Z+
     93a:	d1 90       	ld	r13, Z+
    uint8_t v_numOfDigitsToDisp_u8;
#if (Enable_LCD_DisplayFloatNumber == 1)  
    double v_floatNum_f32;
#endif

    va_start(argp, argList);
     93c:	8f 01       	movw	r16, r30

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
     93e:	f6 01       	movw	r30, r12
     940:	80 81       	ld	r24, Z
     942:	88 23       	and	r24, r24
     944:	09 f4       	brne	.+2      	; 0x948 <LCD_Printf+0x2e>
     946:	2c c1       	rjmp	.+600    	; 0xba0 <LCD_Printf+0x286>
    {

        ch= *ptr;
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
     948:	85 32       	cpi	r24, 0x25	; 37
     94a:	09 f0       	breq	.+2      	; 0x94e <LCD_Printf+0x34>
     94c:	0e c1       	rjmp	.+540    	; 0xb6a <LCD_Printf+0x250>
        {
            ptr++;
     94e:	76 01       	movw	r14, r12
     950:	8f ef       	ldi	r24, 0xFF	; 255
     952:	e8 1a       	sub	r14, r24
     954:	f8 0a       	sbc	r15, r24
            ch = *ptr;
     956:	f6 01       	movw	r30, r12
     958:	81 81       	ldd	r24, Z+1	; 0x01
           if((ch>=0x30) && (ch<=0x39))
     95a:	90 ed       	ldi	r25, 0xD0	; 208
     95c:	98 0f       	add	r25, r24
     95e:	9a 30       	cpi	r25, 0x0A	; 10
     960:	08 f0       	brcs	.+2      	; 0x964 <LCD_Printf+0x4a>
     962:	b7 c0       	rjmp	.+366    	; 0xad2 <LCD_Printf+0x1b8>
     964:	20 e0       	ldi	r18, 0x00	; 0
            {
               v_numOfDigitsToDisp_u8 = 0;
               while((ch>=0x30) && (ch<=0x39))
     966:	90 ed       	ldi	r25, 0xD0	; 208
     968:	98 0f       	add	r25, r24
     96a:	9a 30       	cpi	r25, 0x0A	; 10
     96c:	58 f4       	brcc	.+22     	; 0x984 <LCD_Printf+0x6a>
                {
                   v_numOfDigitsToDisp_u8 = (v_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
     96e:	fa e0       	ldi	r31, 0x0A	; 10
     970:	2f 9f       	mul	r18, r31
     972:	90 0d       	add	r25, r0
     974:	11 24       	eor	r1, r1
     976:	29 2f       	mov	r18, r25
                   ptr++;
     978:	8f ef       	ldi	r24, 0xFF	; 255
     97a:	e8 1a       	sub	r14, r24
     97c:	f8 0a       	sbc	r15, r24
                   ch = *ptr;
     97e:	f7 01       	movw	r30, r14
     980:	80 81       	ld	r24, Z
     982:	f1 cf       	rjmp	.-30     	; 0x966 <LCD_Printf+0x4c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     984:	88 35       	cpi	r24, 0x58	; 88
     986:	09 f4       	brne	.+2      	; 0x98a <LCD_Printf+0x70>
     988:	a8 c0       	rjmp	.+336    	; 0xada <LCD_Printf+0x1c0>
     98a:	70 f4       	brcc	.+28     	; 0x9a8 <LCD_Printf+0x8e>
     98c:	84 34       	cpi	r24, 0x44	; 68
     98e:	09 f4       	brne	.+2      	; 0x992 <LCD_Printf+0x78>
     990:	50 c0       	rjmp	.+160    	; 0xa32 <LCD_Printf+0x118>
     992:	18 f4       	brcc	.+6      	; 0x99a <LCD_Printf+0x80>
     994:	82 34       	cpi	r24, 0x42	; 66
     996:	d9 f4       	brne	.+54     	; 0x9ce <LCD_Printf+0xb4>
     998:	bd c0       	rjmp	.+378    	; 0xb14 <LCD_Printf+0x1fa>
     99a:	83 35       	cpi	r24, 0x53	; 83
     99c:	09 f4       	brne	.+2      	; 0x9a0 <LCD_Printf+0x86>
     99e:	da c0       	rjmp	.+436    	; 0xb54 <LCD_Printf+0x23a>
     9a0:	85 35       	cpi	r24, 0x55	; 85
     9a2:	09 f4       	brne	.+2      	; 0x9a6 <LCD_Printf+0x8c>
     9a4:	7d c0       	rjmp	.+250    	; 0xaa0 <LCD_Printf+0x186>
     9a6:	c6 c0       	rjmp	.+396    	; 0xb34 <LCD_Printf+0x21a>
     9a8:	86 36       	cpi	r24, 0x66	; 102
     9aa:	09 f4       	brne	.+2      	; 0x9ae <LCD_Printf+0x94>
     9ac:	c5 c0       	rjmp	.+394    	; 0xb38 <LCD_Printf+0x21e>
     9ae:	40 f4       	brcc	.+16     	; 0x9c0 <LCD_Printf+0xa6>
     9b0:	83 36       	cpi	r24, 0x63	; 99
     9b2:	81 f0       	breq	.+32     	; 0x9d4 <LCD_Printf+0xba>
     9b4:	84 36       	cpi	r24, 0x64	; 100
     9b6:	21 f1       	breq	.+72     	; 0xa00 <LCD_Printf+0xe6>
     9b8:	82 36       	cpi	r24, 0x62	; 98
     9ba:	09 f0       	breq	.+2      	; 0x9be <LCD_Printf+0xa4>
     9bc:	d9 c0       	rjmp	.+434    	; 0xb70 <LCD_Printf+0x256>
     9be:	9d c0       	rjmp	.+314    	; 0xafa <LCD_Printf+0x1e0>
     9c0:	85 37       	cpi	r24, 0x75	; 117
     9c2:	09 f4       	brne	.+2      	; 0x9c6 <LCD_Printf+0xac>
     9c4:	59 c0       	rjmp	.+178    	; 0xa78 <LCD_Printf+0x15e>
     9c6:	88 37       	cpi	r24, 0x78	; 120
     9c8:	09 f4       	brne	.+2      	; 0x9cc <LCD_Printf+0xb2>
     9ca:	79 c0       	rjmp	.+242    	; 0xabe <LCD_Printf+0x1a4>
     9cc:	c1 c0       	rjmp	.+386    	; 0xb50 <LCD_Printf+0x236>
     9ce:	83 34       	cpi	r24, 0x43	; 67
     9d0:	08 f4       	brcc	.+2      	; 0x9d4 <LCD_Printf+0xba>
     9d2:	e0 c0       	rjmp	.+448    	; 0xb94 <LCD_Printf+0x27a>
            {
            case 'C':
            case 'c':     /* Argument type is of char, hence read char data from the argp */
                ch = va_arg(argp, int);
     9d4:	68 01       	movw	r12, r16
     9d6:	f2 e0       	ldi	r31, 0x02	; 2
     9d8:	cf 0e       	add	r12, r31
     9da:	d1 1c       	adc	r13, r1
                LCD_DisplayChar(ch);
     9dc:	f8 01       	movw	r30, r16
     9de:	80 81       	ld	r24, Z
     9e0:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     9e4:	c0 c0       	rjmp	.+384    	; 0xb66 <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     9e6:	89 35       	cpi	r24, 0x59	; 89
     9e8:	08 f1       	brcs	.+66     	; 0xa2c <LCD_Printf+0x112>
     9ea:	86 36       	cpi	r24, 0x66	; 102
     9ec:	09 f4       	brne	.+2      	; 0x9f0 <LCD_Printf+0xd6>
     9ee:	a4 c0       	rjmp	.+328    	; 0xb38 <LCD_Printf+0x21e>
     9f0:	08 f0       	brcs	.+2      	; 0x9f4 <LCD_Printf+0xda>
     9f2:	3f c0       	rjmp	.+126    	; 0xa72 <LCD_Printf+0x158>
     9f4:	83 36       	cpi	r24, 0x63	; 99
     9f6:	71 f3       	breq	.-36     	; 0x9d4 <LCD_Printf+0xba>
     9f8:	84 36       	cpi	r24, 0x64	; 100
     9fa:	09 f0       	breq	.+2      	; 0x9fe <LCD_Printf+0xe4>
     9fc:	7b c0       	rjmp	.+246    	; 0xaf4 <LCD_Printf+0x1da>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     9fe:	2f ef       	ldi	r18, 0xFF	; 255
                ch = va_arg(argp, int);
                LCD_DisplayChar(ch);
                break;

            case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                v_num_s16 = va_arg(argp, int);
     a00:	68 01       	movw	r12, r16
     a02:	f2 e0       	ldi	r31, 0x02	; 2
     a04:	cf 0e       	add	r12, r31
     a06:	d1 1c       	adc	r13, r1
     a08:	f8 01       	movw	r30, r16
     a0a:	00 81       	ld	r16, Z
     a0c:	11 81       	ldd	r17, Z+1	; 0x01
                if(v_num_s16<0)
     a0e:	17 ff       	sbrs	r17, 7
     a10:	08 c0       	rjmp	.+16     	; 0xa22 <LCD_Printf+0x108>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
                   v_num_s16 = -v_num_s16;
     a12:	11 95       	neg	r17
     a14:	01 95       	neg	r16
     a16:	11 09       	sbc	r17, r1
                   LCD_DisplayChar('-');
     a18:	8d e2       	ldi	r24, 0x2D	; 45
     a1a:	2d 83       	std	Y+5, r18	; 0x05
     a1c:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     a20:	2d 81       	ldd	r18, Y+5	; 0x05
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
     a22:	a8 01       	movw	r20, r16
     a24:	11 0f       	add	r17, r17
     a26:	66 0b       	sbc	r22, r22
     a28:	77 0b       	sbc	r23, r23
     a2a:	43 c0       	rjmp	.+134    	; 0xab2 <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     a2c:	84 34       	cpi	r24, 0x44	; 68
     a2e:	71 f5       	brne	.+92     	; 0xa8c <LCD_Printf+0x172>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     a30:	2f ef       	ldi	r18, 0xFF	; 255
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s16,v_numOfDigitsToDisp_u8);
                break;
                
            case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                v_num_s32 = va_arg(argp, sint32_t);
     a32:	68 01       	movw	r12, r16
     a34:	f4 e0       	ldi	r31, 0x04	; 4
     a36:	cf 0e       	add	r12, r31
     a38:	d1 1c       	adc	r13, r1
     a3a:	f8 01       	movw	r30, r16
     a3c:	40 81       	ld	r20, Z
     a3e:	51 81       	ldd	r21, Z+1	; 0x01
     a40:	62 81       	ldd	r22, Z+2	; 0x02
     a42:	73 81       	ldd	r23, Z+3	; 0x03
                if(v_num_s32<0)
     a44:	77 ff       	sbrs	r23, 7
     a46:	35 c0       	rjmp	.+106    	; 0xab2 <LCD_Printf+0x198>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */
                   v_num_s32 = -v_num_s32;
     a48:	70 95       	com	r23
     a4a:	60 95       	com	r22
     a4c:	50 95       	com	r21
     a4e:	41 95       	neg	r20
     a50:	5f 4f       	sbci	r21, 0xFF	; 255
     a52:	6f 4f       	sbci	r22, 0xFF	; 255
     a54:	7f 4f       	sbci	r23, 0xFF	; 255
                   LCD_DisplayChar('-');
     a56:	8d e2       	ldi	r24, 0x2D	; 45
     a58:	2d 83       	std	Y+5, r18	; 0x05
     a5a:	49 83       	std	Y+1, r20	; 0x01
     a5c:	5a 83       	std	Y+2, r21	; 0x02
     a5e:	6b 83       	std	Y+3, r22	; 0x03
     a60:	7c 83       	std	Y+4, r23	; 0x04
     a62:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     a66:	7c 81       	ldd	r23, Y+4	; 0x04
     a68:	6b 81       	ldd	r22, Y+3	; 0x03
     a6a:	5a 81       	ldd	r21, Y+2	; 0x02
     a6c:	49 81       	ldd	r20, Y+1	; 0x01
     a6e:	2d 81       	ldd	r18, Y+5	; 0x05
     a70:	20 c0       	rjmp	.+64     	; 0xab2 <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     a72:	85 37       	cpi	r24, 0x75	; 117
     a74:	01 f5       	brne	.+64     	; 0xab6 <LCD_Printf+0x19c>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     a76:	2f ef       	ldi	r18, 0xFF	; 255
                 }
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_s32,v_numOfDigitsToDisp_u8);              
                break;    

            case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                v_num_u16 = va_arg(argp, int);
     a78:	68 01       	movw	r12, r16
     a7a:	f2 e0       	ldi	r31, 0x02	; 2
     a7c:	cf 0e       	add	r12, r31
     a7e:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
     a80:	f8 01       	movw	r30, r16
     a82:	40 81       	ld	r20, Z
     a84:	51 81       	ldd	r21, Z+1	; 0x01
     a86:	60 e0       	ldi	r22, 0x00	; 0
     a88:	70 e0       	ldi	r23, 0x00	; 0
     a8a:	13 c0       	rjmp	.+38     	; 0xab2 <LCD_Printf+0x198>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     a8c:	85 34       	cpi	r24, 0x45	; 69
     a8e:	08 f4       	brcc	.+2      	; 0xa92 <LCD_Printf+0x178>
     a90:	74 c0       	rjmp	.+232    	; 0xb7a <LCD_Printf+0x260>
     a92:	83 35       	cpi	r24, 0x53	; 83
     a94:	09 f4       	brne	.+2      	; 0xa98 <LCD_Printf+0x17e>
     a96:	5e c0       	rjmp	.+188    	; 0xb54 <LCD_Printf+0x23a>
     a98:	85 35       	cpi	r24, 0x55	; 85
     a9a:	09 f0       	breq	.+2      	; 0xa9e <LCD_Printf+0x184>
     a9c:	4b c0       	rjmp	.+150    	; 0xb34 <LCD_Printf+0x21a>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     a9e:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u16 = va_arg(argp, int);
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                break;
            
            case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                v_num_u32 = va_arg(argp, uint32_t);
     aa0:	68 01       	movw	r12, r16
     aa2:	f4 e0       	ldi	r31, 0x04	; 4
     aa4:	cf 0e       	add	r12, r31
     aa6:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
     aa8:	f8 01       	movw	r30, r16
     aaa:	40 81       	ld	r20, Z
     aac:	51 81       	ldd	r21, Z+1	; 0x01
     aae:	62 81       	ldd	r22, Z+2	; 0x02
     ab0:	73 81       	ldd	r23, Z+3	; 0x03
     ab2:	8a e0       	ldi	r24, 0x0A	; 10
     ab4:	1c c0       	rjmp	.+56     	; 0xaee <LCD_Printf+0x1d4>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     ab6:	88 37       	cpi	r24, 0x78	; 120
     ab8:	09 f0       	breq	.+2      	; 0xabc <LCD_Printf+0x1a2>
     aba:	4a c0       	rjmp	.+148    	; 0xb50 <LCD_Printf+0x236>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     abc:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u32 = va_arg(argp, uint32_t);
                LCD_DisplayNumber(C_DECIMAL_U8,v_num_u32,v_numOfDigitsToDisp_u8);               
                break;            

            case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u16 = va_arg(argp, int);
     abe:	68 01       	movw	r12, r16
     ac0:	f2 e0       	ldi	r31, 0x02	; 2
     ac2:	cf 0e       	add	r12, r31
     ac4:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
     ac6:	f8 01       	movw	r30, r16
     ac8:	40 81       	ld	r20, Z
     aca:	51 81       	ldd	r21, Z+1	; 0x01
     acc:	60 e0       	ldi	r22, 0x00	; 0
     ace:	70 e0       	ldi	r23, 0x00	; 0
     ad0:	0d c0       	rjmp	.+26     	; 0xaec <LCD_Printf+0x1d2>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     ad2:	88 35       	cpi	r24, 0x58	; 88
     ad4:	09 f0       	breq	.+2      	; 0xad8 <LCD_Printf+0x1be>
     ad6:	87 cf       	rjmp	.-242    	; 0x9e6 <LCD_Printf+0xcc>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     ad8:	2f ef       	ldi	r18, 0xFF	; 255
                v_num_u16 = va_arg(argp, int);
                LCD_DisplayNumber(C_HEX_U8,v_num_u16,v_numOfDigitsToDisp_u8);
                break;

            case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                v_num_u32 = va_arg(argp, uint32_t);
     ada:	68 01       	movw	r12, r16
     adc:	f4 e0       	ldi	r31, 0x04	; 4
     ade:	cf 0e       	add	r12, r31
     ae0:	d1 1c       	adc	r13, r1
                LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
     ae2:	f8 01       	movw	r30, r16
     ae4:	40 81       	ld	r20, Z
     ae6:	51 81       	ldd	r21, Z+1	; 0x01
     ae8:	62 81       	ldd	r22, Z+2	; 0x02
     aea:	73 81       	ldd	r23, Z+3	; 0x03
     aec:	80 e1       	ldi	r24, 0x10	; 16
     aee:	0e 94 bf 03 	call	0x77e	; 0x77e <LCD_DisplayNumber>
     af2:	39 c0       	rjmp	.+114    	; 0xb66 <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     af4:	82 36       	cpi	r24, 0x62	; 98
     af6:	e1 f5       	brne	.+120    	; 0xb70 <LCD_Printf+0x256>
                   ch = *ptr;
                }
            }
            else
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
     af8:	2f ef       	ldi	r18, 0xFF	; 255
                LCD_DisplayNumber(C_HEX_U8,v_num_u32,v_numOfDigitsToDisp_u8);                
                break;

            
            case 'b':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u16 = va_arg(argp, int);
     afa:	68 01       	movw	r12, r16
     afc:	f2 e0       	ldi	r31, 0x02	; 2
     afe:	cf 0e       	add	r12, r31
     b00:	d1 1c       	adc	r13, r1
     b02:	f8 01       	movw	r30, r16
     b04:	60 81       	ld	r22, Z
     b06:	71 81       	ldd	r23, Z+1	; 0x01
                if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
     b08:	2f 3f       	cpi	r18, 0xFF	; 255
     b0a:	09 f4       	brne	.+2      	; 0xb0e <LCD_Printf+0x1f4>
                   v_numOfDigitsToDisp_u8 = 16;
     b0c:	20 e1       	ldi	r18, 0x10	; 16
                LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
     b0e:	80 e0       	ldi	r24, 0x00	; 0
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	0c c0       	rjmp	.+24     	; 0xb2c <LCD_Printf+0x212>
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);
     b14:	68 01       	movw	r12, r16
     b16:	f4 e0       	ldi	r31, 0x04	; 4
     b18:	cf 0e       	add	r12, r31
     b1a:	d1 1c       	adc	r13, r1
     b1c:	f8 01       	movw	r30, r16
     b1e:	60 81       	ld	r22, Z
     b20:	71 81       	ldd	r23, Z+1	; 0x01
     b22:	82 81       	ldd	r24, Z+2	; 0x02
     b24:	93 81       	ldd	r25, Z+3	; 0x03
                if(v_numOfDigitsToDisp_u8 == C_MaxDigitsToDisplayUsingPrintf_U8)
     b26:	2f 3f       	cpi	r18, 0xFF	; 255
     b28:	09 f4       	brne	.+2      	; 0xb2c <LCD_Printf+0x212>
                   v_numOfDigitsToDisp_u8 = 16;                
     b2a:	20 e1       	ldi	r18, 0x10	; 16
     b2c:	42 2f       	mov	r20, r18
     b2e:	0e 94 76 03 	call	0x6ec	; 0x6ec <LCD_DisplayNumber.part.3>
     b32:	19 c0       	rjmp	.+50     	; 0xb66 <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b34:	86 34       	cpi	r24, 0x46	; 70
     b36:	e1 f4       	brne	.+56     	; 0xb70 <LCD_Printf+0x256>


            case 'F':
            case 'f': /* Argument type is of float, hence read double data from the argp */
#if (Enable_LCD_DisplayFloatNumber == 1)  
                v_floatNum_f32 = va_arg(argp, double);              
     b38:	68 01       	movw	r12, r16
     b3a:	f4 e0       	ldi	r31, 0x04	; 4
     b3c:	cf 0e       	add	r12, r31
     b3e:	d1 1c       	adc	r13, r1
                LCD_DisplayFloatNumber(v_floatNum_f32);
     b40:	f8 01       	movw	r30, r16
     b42:	60 81       	ld	r22, Z
     b44:	71 81       	ldd	r23, Z+1	; 0x01
     b46:	82 81       	ldd	r24, Z+2	; 0x02
     b48:	93 81       	ldd	r25, Z+3	; 0x03
     b4a:	0e 94 56 04 	call	0x8ac	; 0x8ac <LCD_DisplayFloatNumber>
     b4e:	0b c0       	rjmp	.+22     	; 0xb66 <LCD_Printf+0x24c>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b50:	83 37       	cpi	r24, 0x73	; 115
     b52:	71 f4       	brne	.+28     	; 0xb70 <LCD_Printf+0x256>
                break;


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
     b54:	68 01       	movw	r12, r16
     b56:	f2 e0       	ldi	r31, 0x02	; 2
     b58:	cf 0e       	add	r12, r31
     b5a:	d1 1c       	adc	r13, r1
                LCD_DisplayString(str);                
     b5c:	f8 01       	movw	r30, r16
     b5e:	80 81       	ld	r24, Z
     b60:	91 81       	ldd	r25, Z+1	; 0x01
     b62:	0e 94 b3 03 	call	0x766	; 0x766 <LCD_DisplayString>
                break;


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
     b66:	86 01       	movw	r16, r12
                LCD_DisplayString(str);                
                break;
     b68:	03 c0       	rjmp	.+6      	; 0xb70 <LCD_Printf+0x256>
            }
        }
        else
        {
            /* As '%' is not detected display/transmit the char passed */
            LCD_DisplayChar(ch);
     b6a:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
     b6e:	76 01       	movw	r14, r12
#endif

    va_start(argp, argList);

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
     b70:	67 01       	movw	r12, r14
     b72:	ff ef       	ldi	r31, 0xFF	; 255
     b74:	cf 1a       	sub	r12, r31
     b76:	df 0a       	sbc	r13, r31
     b78:	e2 ce       	rjmp	.-572    	; 0x93e <LCD_Printf+0x24>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b7a:	82 34       	cpi	r24, 0x42	; 66
     b7c:	09 f0       	breq	.+2      	; 0xb80 <LCD_Printf+0x266>
     b7e:	27 cf       	rjmp	.-434    	; 0x9ce <LCD_Printf+0xb4>
                   v_numOfDigitsToDisp_u8 = 16;
                LCD_DisplayNumber(C_BINARY_U8,v_num_u16,v_numOfDigitsToDisp_u8);                
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                v_num_u32 = va_arg(argp, uint32_t);
     b80:	68 01       	movw	r12, r16
     b82:	f4 e0       	ldi	r31, 0x04	; 4
     b84:	cf 0e       	add	r12, r31
     b86:	d1 1c       	adc	r13, r1
     b88:	f8 01       	movw	r30, r16
     b8a:	60 81       	ld	r22, Z
     b8c:	71 81       	ldd	r23, Z+1	; 0x01
     b8e:	82 81       	ldd	r24, Z+2	; 0x02
     b90:	93 81       	ldd	r25, Z+3	; 0x03
     b92:	cb cf       	rjmp	.-106    	; 0xb2a <LCD_Printf+0x210>
            {
              v_numOfDigitsToDisp_u8 = C_MaxDigitsToDisplayUsingPrintf_U8;
            }                


            switch(ch)       /* Decode the type of the argument */
     b94:	85 32       	cpi	r24, 0x25	; 37
     b96:	61 f7       	brne	.-40     	; 0xb70 <LCD_Printf+0x256>
                str = va_arg(argp, char *);
                LCD_DisplayString(str);                
                break;

            case '%':
                LCD_DisplayChar('%');
     b98:	85 e2       	ldi	r24, 0x25	; 37
     b9a:	0e 94 4a 03 	call	0x694	; 0x694 <LCD_DisplayChar>
                break;
     b9e:	e8 cf       	rjmp	.-48     	; 0xb70 <LCD_Printf+0x256>
            LCD_DisplayChar(ch);
        }
    }

    va_end(argp);
}
     ba0:	0f 90       	pop	r0
     ba2:	0f 90       	pop	r0
     ba4:	0f 90       	pop	r0
     ba6:	0f 90       	pop	r0
     ba8:	0f 90       	pop	r0
     baa:	df 91       	pop	r29
     bac:	cf 91       	pop	r28
     bae:	1f 91       	pop	r17
     bb0:	0f 91       	pop	r16
     bb2:	ff 90       	pop	r15
     bb4:	ef 90       	pop	r14
     bb6:	df 90       	pop	r13
     bb8:	cf 90       	pop	r12
     bba:	08 95       	ret

00000bbc <main>:
#include "rtc.h"
#include "lcd.h"
int main() 
{
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	27 97       	sbiw	r28, 0x07	; 7
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	de bf       	out	0x3e, r29	; 62
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	cd bf       	out	0x3d, r28	; 61
    rtc_t rtc;

    /*Connect RS->PB0, RW->PB1, EN->PB2 and data bus to PORTB.4 to PORTB.7*/
    LCD_SetUp(PB_0,PB_1,PB_2,P_NC,P_NC,P_NC,P_NC,PC_4,PC_5,PC_6,PC_7);
     bd0:	87 e1       	ldi	r24, 0x17	; 23
     bd2:	8f 93       	push	r24
     bd4:	16 e1       	ldi	r17, 0x16	; 22
     bd6:	1f 93       	push	r17
     bd8:	85 e1       	ldi	r24, 0x15	; 21
     bda:	88 2e       	mov	r8, r24
     bdc:	94 e1       	ldi	r25, 0x14	; 20
     bde:	a9 2e       	mov	r10, r25
     be0:	cc 24       	eor	r12, r12
     be2:	ca 94       	dec	r12
     be4:	ee 24       	eor	r14, r14
     be6:	ea 94       	dec	r14
     be8:	0f ef       	ldi	r16, 0xFF	; 255
     bea:	2f ef       	ldi	r18, 0xFF	; 255
     bec:	4a e0       	ldi	r20, 0x0A	; 10
     bee:	69 e0       	ldi	r22, 0x09	; 9
     bf0:	88 e0       	ldi	r24, 0x08	; 8
     bf2:	0e 94 4f 02 	call	0x49e	; 0x49e <LCD_SetUp>
    LCD_Init(2,16);
     bf6:	60 e1       	ldi	r22, 0x10	; 16
     bf8:	82 e0       	ldi	r24, 0x02	; 2
     bfa:	0e 94 ef 02 	call	0x5de	; 0x5de <LCD_Init>
	
    /*Connect SCL->PC0, SDA->PC1*/    
    RTC_Init();
     bfe:	0e 94 37 06 	call	0xc6e	; 0xc6e <RTC_Init>
    rtc.hour = 0x10; //  10:40:20 am
     c02:	80 e1       	ldi	r24, 0x10	; 16
     c04:	8b 83       	std	Y+3, r24	; 0x03
    rtc.min =  0x40;
     c06:	80 e4       	ldi	r24, 0x40	; 64
     c08:	8a 83       	std	Y+2, r24	; 0x02
    rtc.sec =  0x00;
     c0a:	19 82       	std	Y+1, r1	; 0x01

    rtc.date = 0x01; //1st Jan 2016
     c0c:	81 e0       	ldi	r24, 0x01	; 1
     c0e:	8d 83       	std	Y+5, r24	; 0x05
    rtc.month = 0x01;
     c10:	8e 83       	std	Y+6, r24	; 0x06
    rtc.year = 0x16;
     c12:	1f 83       	std	Y+7, r17	; 0x07
    rtc.weekDay = 5; // Friday: 5th day of week considering monday as first day.
     c14:	85 e0       	ldi	r24, 0x05	; 5
     c16:	8c 83       	std	Y+4, r24	; 0x04
    /*##### Set the time and Date only once. Once the Time and Date is set, comment these lines
         and reflash the code. Else the time will be set every time the controller is reset*/
    RTC_SetDateTime(&rtc);  //  10:40:20 am, 1st Jan 2016
     c18:	ce 01       	movw	r24, r28
     c1a:	01 96       	adiw	r24, 0x01	; 1
     c1c:	0e 94 46 06 	call	0xc8c	; 0xc8c <RTC_SetDateTime>
     c20:	0f 90       	pop	r0
     c22:	0f 90       	pop	r0
    /* Display the Time and Date continuously */
    while(1)
    {
        RTC_GetDateTime(&rtc);
        LCD_GoToLine(0);
        LCD_Printf("time:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)rtc.hour,(uint16_t)rtc.min,(uint16_t)rtc.sec,(uint16_t)rtc.date,(uint16_t)rtc.month,(uint16_t)rtc.year);
     c24:	04 e6       	ldi	r16, 0x64	; 100
     c26:	10 e0       	ldi	r17, 0x00	; 0
         and reflash the code. Else the time will be set every time the controller is reset*/
    RTC_SetDateTime(&rtc);  //  10:40:20 am, 1st Jan 2016
    /* Display the Time and Date continuously */
    while(1)
    {
        RTC_GetDateTime(&rtc);
     c28:	ce 01       	movw	r24, r28
     c2a:	01 96       	adiw	r24, 0x01	; 1
     c2c:	0e 94 6a 06 	call	0xcd4	; 0xcd4 <RTC_GetDateTime>
        LCD_GoToLine(0);
     c30:	80 e0       	ldi	r24, 0x00	; 0
     c32:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <LCD_GoToLine>
        LCD_Printf("time:%2x:%2x:%2x  \nDate:%2x/%2x/%2x",(uint16_t)rtc.hour,(uint16_t)rtc.min,(uint16_t)rtc.sec,(uint16_t)rtc.date,(uint16_t)rtc.month,(uint16_t)rtc.year);
     c36:	8f 81       	ldd	r24, Y+7	; 0x07
     c38:	1f 92       	push	r1
     c3a:	8f 93       	push	r24
     c3c:	8e 81       	ldd	r24, Y+6	; 0x06
     c3e:	1f 92       	push	r1
     c40:	8f 93       	push	r24
     c42:	8d 81       	ldd	r24, Y+5	; 0x05
     c44:	1f 92       	push	r1
     c46:	8f 93       	push	r24
     c48:	89 81       	ldd	r24, Y+1	; 0x01
     c4a:	1f 92       	push	r1
     c4c:	8f 93       	push	r24
     c4e:	8a 81       	ldd	r24, Y+2	; 0x02
     c50:	1f 92       	push	r1
     c52:	8f 93       	push	r24
     c54:	8b 81       	ldd	r24, Y+3	; 0x03
     c56:	1f 92       	push	r1
     c58:	8f 93       	push	r24
     c5a:	1f 93       	push	r17
     c5c:	0f 93       	push	r16
     c5e:	0e 94 8d 04 	call	0x91a	; 0x91a <LCD_Printf>
    }
     c62:	0f b6       	in	r0, 0x3f	; 63
     c64:	f8 94       	cli
     c66:	de bf       	out	0x3e, r29	; 62
     c68:	0f be       	out	0x3f, r0	; 63
     c6a:	cd bf       	out	0x3d, r28	; 61
     c6c:	dd cf       	rjmp	.-70     	; 0xc28 <main+0x6c>

00000c6e <RTC_Init>:

 * description :This function is used to Initialize the Ds1307 RTC.
***************************************************************************************************/
void RTC_Init(void)
{
    I2C_Init();                             // Initialize the I2c module.
     c6e:	0e 94 5e 01 	call	0x2bc	; 0x2bc <I2C_Init>
    I2C_Start();                            // Start I2C communication
     c72:	0e 94 64 01 	call	0x2c8	; 0x2c8 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // Connect to DS1307 by sending its ID on I2c Bus
     c76:	80 ed       	ldi	r24, 0xD0	; 208
     c78:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(C_Ds1307ControlRegAddress_U8);// Select the Ds1307 ControlRegister to configure Ds1307
     c7c:	87 e0       	ldi	r24, 0x07	; 7
     c7e:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Write(0x00);                        // Write 0x00 to Control register to disable SQW-Out
     c82:	80 e0       	ldi	r24, 0x00	; 0
     c84:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Stop();                             // Stop I2C communication after initializing DS1307
     c88:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <I2C_Stop>

00000c8c <RTC_SetDateTime>:
        Note: The date and time should be of BCD format, 
             like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
                  0x15,0x08,0x47 for 15th day,8th month and 47th year.                 
***************************************************************************************************/
void RTC_SetDateTime(rtc_t *rtc)
{
     c8c:	cf 93       	push	r28
     c8e:	df 93       	push	r29
     c90:	ec 01       	movw	r28, r24
    I2C_Start();                          // Start I2C communication
     c92:	0e 94 64 01 	call	0x2c8	; 0x2c8 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);      // connect to DS1307 by sending its ID on I2c Bus
     c96:	80 ed       	ldi	r24, 0xD0	; 208
     c98:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request sec RAM address at 00H
     c9c:	80 e0       	ldi	r24, 0x00	; 0
     c9e:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Write(rtc->sec);                    // Write sec from RAM address 00H
     ca2:	88 81       	ld	r24, Y
     ca4:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->min);                    // Write min from RAM address 01H
     ca8:	89 81       	ldd	r24, Y+1	; 0x01
     caa:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->hour);                    // Write hour from RAM address 02H
     cae:	8a 81       	ldd	r24, Y+2	; 0x02
     cb0:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
     cb4:	8b 81       	ldd	r24, Y+3	; 0x03
     cb6:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
     cba:	8c 81       	ldd	r24, Y+4	; 0x04
     cbc:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
     cc0:	8d 81       	ldd	r24, Y+5	; 0x05
     cc2:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(rtc->year);                    // Write year on RAM address 06h
     cc6:	8e 81       	ldd	r24, Y+6	; 0x06
     cc8:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Stop();                              // Stop I2C communication after Setting the Date
}
     ccc:	df 91       	pop	r29
     cce:	cf 91       	pop	r28
    I2C_Write(rtc->weekDay);                // Write weekDay on RAM address 03H
    I2C_Write(rtc->date);                    // Write date on RAM address 04H
    I2C_Write(rtc->month);                    // Write month on RAM address 05H
    I2C_Write(rtc->year);                    // Write year on RAM address 06h

    I2C_Stop();                              // Stop I2C communication after Setting the Date
     cd0:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <I2C_Stop>

00000cd4 <RTC_GetDateTime>:
    Note: The date and time read from Ds1307 will be of BCD format, 
          like 0x12,0x39,0x26 for 12hr,39min and 26sec.    
               0x15,0x08,0x47 for 15th day,8th month and 47th year.              
***************************************************************************************************/
void RTC_GetDateTime(rtc_t *rtc)
{
     cd4:	cf 93       	push	r28
     cd6:	df 93       	push	r29
     cd8:	ec 01       	movw	r28, r24
    I2C_Start();                            // Start I2C communication
     cda:	0e 94 64 01 	call	0x2c8	; 0x2c8 <I2C_Start>

    I2C_Write(C_Ds1307WriteMode_U8);        // connect to DS1307 by sending its ID on I2c Bus
     cde:	80 ed       	ldi	r24, 0xD0	; 208
     ce0:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>
    I2C_Write(C_Ds1307SecondRegAddress_U8); // Request Sec RAM address at 00H
     ce4:	80 e0       	ldi	r24, 0x00	; 0
     ce6:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    I2C_Stop();                                // Stop I2C communication after selecting Sec Register
     cea:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <I2C_Stop>

    I2C_Start();                            // Start I2C communication
     cee:	0e 94 64 01 	call	0x2c8	; 0x2c8 <I2C_Start>
    I2C_Write(C_Ds1307ReadMode_U8);            // connect to DS1307(Read mode) by sending its ID
     cf2:	81 ed       	ldi	r24, 0xD1	; 209
     cf4:	0e 94 70 01 	call	0x2e0	; 0x2e0 <I2C_Write>

    rtc->sec = I2C_Read(1);                // read second and return Positive ACK
     cf8:	81 e0       	ldi	r24, 0x01	; 1
     cfa:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     cfe:	88 83       	st	Y, r24
    rtc->min = I2C_Read(1);                 // read minute and return Positive ACK
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     d06:	89 83       	std	Y+1, r24	; 0x01
    rtc->hour= I2C_Read(1);               // read hour and return Negative/No ACK
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     d0e:	8a 83       	std	Y+2, r24	; 0x02
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     d16:	8b 83       	std	Y+3, r24	; 0x03
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     d1e:	8c 83       	std	Y+4, r24	; 0x04
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
     d20:	81 e0       	ldi	r24, 0x01	; 1
     d22:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     d26:	8d 83       	std	Y+5, r24	; 0x05
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK
     d28:	80 e0       	ldi	r24, 0x00	; 0
     d2a:	0e 94 77 01 	call	0x2ee	; 0x2ee <I2C_Read>
     d2e:	8e 83       	std	Y+6, r24	; 0x06

    I2C_Stop();                              // Stop I2C communication after reading the Date
}
     d30:	df 91       	pop	r29
     d32:	cf 91       	pop	r28
    rtc->weekDay = I2C_Read(1);           // read weekDay and return Positive ACK
    rtc->date= I2C_Read(1);              // read Date and return Positive ACK
    rtc->month=I2C_Read(1);            // read Month and return Positive ACK
    rtc->year =I2C_Read(0);             // read Year and return Negative/No ACK

    I2C_Stop();                              // Stop I2C communication after reading the Date
     d34:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <I2C_Stop>

00000d38 <__subsf3>:
     d38:	50 58       	subi	r21, 0x80	; 128

00000d3a <__addsf3>:
     d3a:	bb 27       	eor	r27, r27
     d3c:	aa 27       	eor	r26, r26
     d3e:	0e 94 b4 06 	call	0xd68	; 0xd68 <__addsf3x>
     d42:	0c 94 8c 07 	jmp	0xf18	; 0xf18 <__fp_round>
     d46:	0e 94 7e 07 	call	0xefc	; 0xefc <__fp_pscA>
     d4a:	38 f0       	brcs	.+14     	; 0xd5a <__addsf3+0x20>
     d4c:	0e 94 85 07 	call	0xf0a	; 0xf0a <__fp_pscB>
     d50:	20 f0       	brcs	.+8      	; 0xd5a <__addsf3+0x20>
     d52:	39 f4       	brne	.+14     	; 0xd62 <__addsf3+0x28>
     d54:	9f 3f       	cpi	r25, 0xFF	; 255
     d56:	19 f4       	brne	.+6      	; 0xd5e <__addsf3+0x24>
     d58:	26 f4       	brtc	.+8      	; 0xd62 <__addsf3+0x28>
     d5a:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <__fp_nan>
     d5e:	0e f4       	brtc	.+2      	; 0xd62 <__addsf3+0x28>
     d60:	e0 95       	com	r30
     d62:	e7 fb       	bst	r30, 7
     d64:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>

00000d68 <__addsf3x>:
     d68:	e9 2f       	mov	r30, r25
     d6a:	0e 94 9d 07 	call	0xf3a	; 0xf3a <__fp_split3>
     d6e:	58 f3       	brcs	.-42     	; 0xd46 <__addsf3+0xc>
     d70:	ba 17       	cp	r27, r26
     d72:	62 07       	cpc	r22, r18
     d74:	73 07       	cpc	r23, r19
     d76:	84 07       	cpc	r24, r20
     d78:	95 07       	cpc	r25, r21
     d7a:	20 f0       	brcs	.+8      	; 0xd84 <__addsf3x+0x1c>
     d7c:	79 f4       	brne	.+30     	; 0xd9c <__addsf3x+0x34>
     d7e:	a6 f5       	brtc	.+104    	; 0xde8 <__addsf3x+0x80>
     d80:	0c 94 bf 07 	jmp	0xf7e	; 0xf7e <__fp_zero>
     d84:	0e f4       	brtc	.+2      	; 0xd88 <__addsf3x+0x20>
     d86:	e0 95       	com	r30
     d88:	0b 2e       	mov	r0, r27
     d8a:	ba 2f       	mov	r27, r26
     d8c:	a0 2d       	mov	r26, r0
     d8e:	0b 01       	movw	r0, r22
     d90:	b9 01       	movw	r22, r18
     d92:	90 01       	movw	r18, r0
     d94:	0c 01       	movw	r0, r24
     d96:	ca 01       	movw	r24, r20
     d98:	a0 01       	movw	r20, r0
     d9a:	11 24       	eor	r1, r1
     d9c:	ff 27       	eor	r31, r31
     d9e:	59 1b       	sub	r21, r25
     da0:	99 f0       	breq	.+38     	; 0xdc8 <__addsf3x+0x60>
     da2:	59 3f       	cpi	r21, 0xF9	; 249
     da4:	50 f4       	brcc	.+20     	; 0xdba <__addsf3x+0x52>
     da6:	50 3e       	cpi	r21, 0xE0	; 224
     da8:	68 f1       	brcs	.+90     	; 0xe04 <__addsf3x+0x9c>
     daa:	1a 16       	cp	r1, r26
     dac:	f0 40       	sbci	r31, 0x00	; 0
     dae:	a2 2f       	mov	r26, r18
     db0:	23 2f       	mov	r18, r19
     db2:	34 2f       	mov	r19, r20
     db4:	44 27       	eor	r20, r20
     db6:	58 5f       	subi	r21, 0xF8	; 248
     db8:	f3 cf       	rjmp	.-26     	; 0xda0 <__addsf3x+0x38>
     dba:	46 95       	lsr	r20
     dbc:	37 95       	ror	r19
     dbe:	27 95       	ror	r18
     dc0:	a7 95       	ror	r26
     dc2:	f0 40       	sbci	r31, 0x00	; 0
     dc4:	53 95       	inc	r21
     dc6:	c9 f7       	brne	.-14     	; 0xdba <__addsf3x+0x52>
     dc8:	7e f4       	brtc	.+30     	; 0xde8 <__addsf3x+0x80>
     dca:	1f 16       	cp	r1, r31
     dcc:	ba 0b       	sbc	r27, r26
     dce:	62 0b       	sbc	r22, r18
     dd0:	73 0b       	sbc	r23, r19
     dd2:	84 0b       	sbc	r24, r20
     dd4:	ba f0       	brmi	.+46     	; 0xe04 <__addsf3x+0x9c>
     dd6:	91 50       	subi	r25, 0x01	; 1
     dd8:	a1 f0       	breq	.+40     	; 0xe02 <__addsf3x+0x9a>
     dda:	ff 0f       	add	r31, r31
     ddc:	bb 1f       	adc	r27, r27
     dde:	66 1f       	adc	r22, r22
     de0:	77 1f       	adc	r23, r23
     de2:	88 1f       	adc	r24, r24
     de4:	c2 f7       	brpl	.-16     	; 0xdd6 <__addsf3x+0x6e>
     de6:	0e c0       	rjmp	.+28     	; 0xe04 <__addsf3x+0x9c>
     de8:	ba 0f       	add	r27, r26
     dea:	62 1f       	adc	r22, r18
     dec:	73 1f       	adc	r23, r19
     dee:	84 1f       	adc	r24, r20
     df0:	48 f4       	brcc	.+18     	; 0xe04 <__addsf3x+0x9c>
     df2:	87 95       	ror	r24
     df4:	77 95       	ror	r23
     df6:	67 95       	ror	r22
     df8:	b7 95       	ror	r27
     dfa:	f7 95       	ror	r31
     dfc:	9e 3f       	cpi	r25, 0xFE	; 254
     dfe:	08 f0       	brcs	.+2      	; 0xe02 <__addsf3x+0x9a>
     e00:	b0 cf       	rjmp	.-160    	; 0xd62 <__addsf3+0x28>
     e02:	93 95       	inc	r25
     e04:	88 0f       	add	r24, r24
     e06:	08 f0       	brcs	.+2      	; 0xe0a <__addsf3x+0xa2>
     e08:	99 27       	eor	r25, r25
     e0a:	ee 0f       	add	r30, r30
     e0c:	97 95       	ror	r25
     e0e:	87 95       	ror	r24
     e10:	08 95       	ret

00000e12 <__fixunssfsi>:
     e12:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__fp_splitA>
     e16:	88 f0       	brcs	.+34     	; 0xe3a <__fixunssfsi+0x28>
     e18:	9f 57       	subi	r25, 0x7F	; 127
     e1a:	98 f0       	brcs	.+38     	; 0xe42 <__fixunssfsi+0x30>
     e1c:	b9 2f       	mov	r27, r25
     e1e:	99 27       	eor	r25, r25
     e20:	b7 51       	subi	r27, 0x17	; 23
     e22:	b0 f0       	brcs	.+44     	; 0xe50 <__fixunssfsi+0x3e>
     e24:	e1 f0       	breq	.+56     	; 0xe5e <__fixunssfsi+0x4c>
     e26:	66 0f       	add	r22, r22
     e28:	77 1f       	adc	r23, r23
     e2a:	88 1f       	adc	r24, r24
     e2c:	99 1f       	adc	r25, r25
     e2e:	1a f0       	brmi	.+6      	; 0xe36 <__fixunssfsi+0x24>
     e30:	ba 95       	dec	r27
     e32:	c9 f7       	brne	.-14     	; 0xe26 <__fixunssfsi+0x14>
     e34:	14 c0       	rjmp	.+40     	; 0xe5e <__fixunssfsi+0x4c>
     e36:	b1 30       	cpi	r27, 0x01	; 1
     e38:	91 f0       	breq	.+36     	; 0xe5e <__fixunssfsi+0x4c>
     e3a:	0e 94 bf 07 	call	0xf7e	; 0xf7e <__fp_zero>
     e3e:	b1 e0       	ldi	r27, 0x01	; 1
     e40:	08 95       	ret
     e42:	0c 94 bf 07 	jmp	0xf7e	; 0xf7e <__fp_zero>
     e46:	67 2f       	mov	r22, r23
     e48:	78 2f       	mov	r23, r24
     e4a:	88 27       	eor	r24, r24
     e4c:	b8 5f       	subi	r27, 0xF8	; 248
     e4e:	39 f0       	breq	.+14     	; 0xe5e <__fixunssfsi+0x4c>
     e50:	b9 3f       	cpi	r27, 0xF9	; 249
     e52:	cc f3       	brlt	.-14     	; 0xe46 <__fixunssfsi+0x34>
     e54:	86 95       	lsr	r24
     e56:	77 95       	ror	r23
     e58:	67 95       	ror	r22
     e5a:	b3 95       	inc	r27
     e5c:	d9 f7       	brne	.-10     	; 0xe54 <__fixunssfsi+0x42>
     e5e:	3e f4       	brtc	.+14     	; 0xe6e <__fixunssfsi+0x5c>
     e60:	90 95       	com	r25
     e62:	80 95       	com	r24
     e64:	70 95       	com	r23
     e66:	61 95       	neg	r22
     e68:	7f 4f       	sbci	r23, 0xFF	; 255
     e6a:	8f 4f       	sbci	r24, 0xFF	; 255
     e6c:	9f 4f       	sbci	r25, 0xFF	; 255
     e6e:	08 95       	ret

00000e70 <__floatunsisf>:
     e70:	e8 94       	clt
     e72:	09 c0       	rjmp	.+18     	; 0xe86 <__floatsisf+0x12>

00000e74 <__floatsisf>:
     e74:	97 fb       	bst	r25, 7
     e76:	3e f4       	brtc	.+14     	; 0xe86 <__floatsisf+0x12>
     e78:	90 95       	com	r25
     e7a:	80 95       	com	r24
     e7c:	70 95       	com	r23
     e7e:	61 95       	neg	r22
     e80:	7f 4f       	sbci	r23, 0xFF	; 255
     e82:	8f 4f       	sbci	r24, 0xFF	; 255
     e84:	9f 4f       	sbci	r25, 0xFF	; 255
     e86:	99 23       	and	r25, r25
     e88:	a9 f0       	breq	.+42     	; 0xeb4 <__floatsisf+0x40>
     e8a:	f9 2f       	mov	r31, r25
     e8c:	96 e9       	ldi	r25, 0x96	; 150
     e8e:	bb 27       	eor	r27, r27
     e90:	93 95       	inc	r25
     e92:	f6 95       	lsr	r31
     e94:	87 95       	ror	r24
     e96:	77 95       	ror	r23
     e98:	67 95       	ror	r22
     e9a:	b7 95       	ror	r27
     e9c:	f1 11       	cpse	r31, r1
     e9e:	f8 cf       	rjmp	.-16     	; 0xe90 <__floatsisf+0x1c>
     ea0:	fa f4       	brpl	.+62     	; 0xee0 <__floatsisf+0x6c>
     ea2:	bb 0f       	add	r27, r27
     ea4:	11 f4       	brne	.+4      	; 0xeaa <__floatsisf+0x36>
     ea6:	60 ff       	sbrs	r22, 0
     ea8:	1b c0       	rjmp	.+54     	; 0xee0 <__floatsisf+0x6c>
     eaa:	6f 5f       	subi	r22, 0xFF	; 255
     eac:	7f 4f       	sbci	r23, 0xFF	; 255
     eae:	8f 4f       	sbci	r24, 0xFF	; 255
     eb0:	9f 4f       	sbci	r25, 0xFF	; 255
     eb2:	16 c0       	rjmp	.+44     	; 0xee0 <__floatsisf+0x6c>
     eb4:	88 23       	and	r24, r24
     eb6:	11 f0       	breq	.+4      	; 0xebc <__floatsisf+0x48>
     eb8:	96 e9       	ldi	r25, 0x96	; 150
     eba:	11 c0       	rjmp	.+34     	; 0xede <__floatsisf+0x6a>
     ebc:	77 23       	and	r23, r23
     ebe:	21 f0       	breq	.+8      	; 0xec8 <__floatsisf+0x54>
     ec0:	9e e8       	ldi	r25, 0x8E	; 142
     ec2:	87 2f       	mov	r24, r23
     ec4:	76 2f       	mov	r23, r22
     ec6:	05 c0       	rjmp	.+10     	; 0xed2 <__floatsisf+0x5e>
     ec8:	66 23       	and	r22, r22
     eca:	71 f0       	breq	.+28     	; 0xee8 <__floatsisf+0x74>
     ecc:	96 e8       	ldi	r25, 0x86	; 134
     ece:	86 2f       	mov	r24, r22
     ed0:	70 e0       	ldi	r23, 0x00	; 0
     ed2:	60 e0       	ldi	r22, 0x00	; 0
     ed4:	2a f0       	brmi	.+10     	; 0xee0 <__floatsisf+0x6c>
     ed6:	9a 95       	dec	r25
     ed8:	66 0f       	add	r22, r22
     eda:	77 1f       	adc	r23, r23
     edc:	88 1f       	adc	r24, r24
     ede:	da f7       	brpl	.-10     	; 0xed6 <__floatsisf+0x62>
     ee0:	88 0f       	add	r24, r24
     ee2:	96 95       	lsr	r25
     ee4:	87 95       	ror	r24
     ee6:	97 f9       	bld	r25, 7
     ee8:	08 95       	ret

00000eea <__fp_inf>:
     eea:	97 f9       	bld	r25, 7
     eec:	9f 67       	ori	r25, 0x7F	; 127
     eee:	80 e8       	ldi	r24, 0x80	; 128
     ef0:	70 e0       	ldi	r23, 0x00	; 0
     ef2:	60 e0       	ldi	r22, 0x00	; 0
     ef4:	08 95       	ret

00000ef6 <__fp_nan>:
     ef6:	9f ef       	ldi	r25, 0xFF	; 255
     ef8:	80 ec       	ldi	r24, 0xC0	; 192
     efa:	08 95       	ret

00000efc <__fp_pscA>:
     efc:	00 24       	eor	r0, r0
     efe:	0a 94       	dec	r0
     f00:	16 16       	cp	r1, r22
     f02:	17 06       	cpc	r1, r23
     f04:	18 06       	cpc	r1, r24
     f06:	09 06       	cpc	r0, r25
     f08:	08 95       	ret

00000f0a <__fp_pscB>:
     f0a:	00 24       	eor	r0, r0
     f0c:	0a 94       	dec	r0
     f0e:	12 16       	cp	r1, r18
     f10:	13 06       	cpc	r1, r19
     f12:	14 06       	cpc	r1, r20
     f14:	05 06       	cpc	r0, r21
     f16:	08 95       	ret

00000f18 <__fp_round>:
     f18:	09 2e       	mov	r0, r25
     f1a:	03 94       	inc	r0
     f1c:	00 0c       	add	r0, r0
     f1e:	11 f4       	brne	.+4      	; 0xf24 <__fp_round+0xc>
     f20:	88 23       	and	r24, r24
     f22:	52 f0       	brmi	.+20     	; 0xf38 <__fp_round+0x20>
     f24:	bb 0f       	add	r27, r27
     f26:	40 f4       	brcc	.+16     	; 0xf38 <__fp_round+0x20>
     f28:	bf 2b       	or	r27, r31
     f2a:	11 f4       	brne	.+4      	; 0xf30 <__fp_round+0x18>
     f2c:	60 ff       	sbrs	r22, 0
     f2e:	04 c0       	rjmp	.+8      	; 0xf38 <__fp_round+0x20>
     f30:	6f 5f       	subi	r22, 0xFF	; 255
     f32:	7f 4f       	sbci	r23, 0xFF	; 255
     f34:	8f 4f       	sbci	r24, 0xFF	; 255
     f36:	9f 4f       	sbci	r25, 0xFF	; 255
     f38:	08 95       	ret

00000f3a <__fp_split3>:
     f3a:	57 fd       	sbrc	r21, 7
     f3c:	90 58       	subi	r25, 0x80	; 128
     f3e:	44 0f       	add	r20, r20
     f40:	55 1f       	adc	r21, r21
     f42:	59 f0       	breq	.+22     	; 0xf5a <__fp_splitA+0x10>
     f44:	5f 3f       	cpi	r21, 0xFF	; 255
     f46:	71 f0       	breq	.+28     	; 0xf64 <__fp_splitA+0x1a>
     f48:	47 95       	ror	r20

00000f4a <__fp_splitA>:
     f4a:	88 0f       	add	r24, r24
     f4c:	97 fb       	bst	r25, 7
     f4e:	99 1f       	adc	r25, r25
     f50:	61 f0       	breq	.+24     	; 0xf6a <__fp_splitA+0x20>
     f52:	9f 3f       	cpi	r25, 0xFF	; 255
     f54:	79 f0       	breq	.+30     	; 0xf74 <__fp_splitA+0x2a>
     f56:	87 95       	ror	r24
     f58:	08 95       	ret
     f5a:	12 16       	cp	r1, r18
     f5c:	13 06       	cpc	r1, r19
     f5e:	14 06       	cpc	r1, r20
     f60:	55 1f       	adc	r21, r21
     f62:	f2 cf       	rjmp	.-28     	; 0xf48 <__fp_split3+0xe>
     f64:	46 95       	lsr	r20
     f66:	f1 df       	rcall	.-30     	; 0xf4a <__fp_splitA>
     f68:	08 c0       	rjmp	.+16     	; 0xf7a <__fp_splitA+0x30>
     f6a:	16 16       	cp	r1, r22
     f6c:	17 06       	cpc	r1, r23
     f6e:	18 06       	cpc	r1, r24
     f70:	99 1f       	adc	r25, r25
     f72:	f1 cf       	rjmp	.-30     	; 0xf56 <__fp_splitA+0xc>
     f74:	86 95       	lsr	r24
     f76:	71 05       	cpc	r23, r1
     f78:	61 05       	cpc	r22, r1
     f7a:	08 94       	sec
     f7c:	08 95       	ret

00000f7e <__fp_zero>:
     f7e:	e8 94       	clt

00000f80 <__fp_szero>:
     f80:	bb 27       	eor	r27, r27
     f82:	66 27       	eor	r22, r22
     f84:	77 27       	eor	r23, r23
     f86:	cb 01       	movw	r24, r22
     f88:	97 f9       	bld	r25, 7
     f8a:	08 95       	ret

00000f8c <__mulsf3>:
     f8c:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <__mulsf3x>
     f90:	0c 94 8c 07 	jmp	0xf18	; 0xf18 <__fp_round>
     f94:	0e 94 7e 07 	call	0xefc	; 0xefc <__fp_pscA>
     f98:	38 f0       	brcs	.+14     	; 0xfa8 <__mulsf3+0x1c>
     f9a:	0e 94 85 07 	call	0xf0a	; 0xf0a <__fp_pscB>
     f9e:	20 f0       	brcs	.+8      	; 0xfa8 <__mulsf3+0x1c>
     fa0:	95 23       	and	r25, r21
     fa2:	11 f0       	breq	.+4      	; 0xfa8 <__mulsf3+0x1c>
     fa4:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>
     fa8:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <__fp_nan>
     fac:	11 24       	eor	r1, r1
     fae:	0c 94 c0 07 	jmp	0xf80	; 0xf80 <__fp_szero>

00000fb2 <__mulsf3x>:
     fb2:	0e 94 9d 07 	call	0xf3a	; 0xf3a <__fp_split3>
     fb6:	70 f3       	brcs	.-36     	; 0xf94 <__mulsf3+0x8>

00000fb8 <__mulsf3_pse>:
     fb8:	95 9f       	mul	r25, r21
     fba:	c1 f3       	breq	.-16     	; 0xfac <__mulsf3+0x20>
     fbc:	95 0f       	add	r25, r21
     fbe:	50 e0       	ldi	r21, 0x00	; 0
     fc0:	55 1f       	adc	r21, r21
     fc2:	62 9f       	mul	r22, r18
     fc4:	f0 01       	movw	r30, r0
     fc6:	72 9f       	mul	r23, r18
     fc8:	bb 27       	eor	r27, r27
     fca:	f0 0d       	add	r31, r0
     fcc:	b1 1d       	adc	r27, r1
     fce:	63 9f       	mul	r22, r19
     fd0:	aa 27       	eor	r26, r26
     fd2:	f0 0d       	add	r31, r0
     fd4:	b1 1d       	adc	r27, r1
     fd6:	aa 1f       	adc	r26, r26
     fd8:	64 9f       	mul	r22, r20
     fda:	66 27       	eor	r22, r22
     fdc:	b0 0d       	add	r27, r0
     fde:	a1 1d       	adc	r26, r1
     fe0:	66 1f       	adc	r22, r22
     fe2:	82 9f       	mul	r24, r18
     fe4:	22 27       	eor	r18, r18
     fe6:	b0 0d       	add	r27, r0
     fe8:	a1 1d       	adc	r26, r1
     fea:	62 1f       	adc	r22, r18
     fec:	73 9f       	mul	r23, r19
     fee:	b0 0d       	add	r27, r0
     ff0:	a1 1d       	adc	r26, r1
     ff2:	62 1f       	adc	r22, r18
     ff4:	83 9f       	mul	r24, r19
     ff6:	a0 0d       	add	r26, r0
     ff8:	61 1d       	adc	r22, r1
     ffa:	22 1f       	adc	r18, r18
     ffc:	74 9f       	mul	r23, r20
     ffe:	33 27       	eor	r19, r19
    1000:	a0 0d       	add	r26, r0
    1002:	61 1d       	adc	r22, r1
    1004:	23 1f       	adc	r18, r19
    1006:	84 9f       	mul	r24, r20
    1008:	60 0d       	add	r22, r0
    100a:	21 1d       	adc	r18, r1
    100c:	82 2f       	mov	r24, r18
    100e:	76 2f       	mov	r23, r22
    1010:	6a 2f       	mov	r22, r26
    1012:	11 24       	eor	r1, r1
    1014:	9f 57       	subi	r25, 0x7F	; 127
    1016:	50 40       	sbci	r21, 0x00	; 0
    1018:	9a f0       	brmi	.+38     	; 0x1040 <__mulsf3_pse+0x88>
    101a:	f1 f0       	breq	.+60     	; 0x1058 <__mulsf3_pse+0xa0>
    101c:	88 23       	and	r24, r24
    101e:	4a f0       	brmi	.+18     	; 0x1032 <__mulsf3_pse+0x7a>
    1020:	ee 0f       	add	r30, r30
    1022:	ff 1f       	adc	r31, r31
    1024:	bb 1f       	adc	r27, r27
    1026:	66 1f       	adc	r22, r22
    1028:	77 1f       	adc	r23, r23
    102a:	88 1f       	adc	r24, r24
    102c:	91 50       	subi	r25, 0x01	; 1
    102e:	50 40       	sbci	r21, 0x00	; 0
    1030:	a9 f7       	brne	.-22     	; 0x101c <__mulsf3_pse+0x64>
    1032:	9e 3f       	cpi	r25, 0xFE	; 254
    1034:	51 05       	cpc	r21, r1
    1036:	80 f0       	brcs	.+32     	; 0x1058 <__mulsf3_pse+0xa0>
    1038:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>
    103c:	0c 94 c0 07 	jmp	0xf80	; 0xf80 <__fp_szero>
    1040:	5f 3f       	cpi	r21, 0xFF	; 255
    1042:	e4 f3       	brlt	.-8      	; 0x103c <__mulsf3_pse+0x84>
    1044:	98 3e       	cpi	r25, 0xE8	; 232
    1046:	d4 f3       	brlt	.-12     	; 0x103c <__mulsf3_pse+0x84>
    1048:	86 95       	lsr	r24
    104a:	77 95       	ror	r23
    104c:	67 95       	ror	r22
    104e:	b7 95       	ror	r27
    1050:	f7 95       	ror	r31
    1052:	e7 95       	ror	r30
    1054:	9f 5f       	subi	r25, 0xFF	; 255
    1056:	c1 f7       	brne	.-16     	; 0x1048 <__mulsf3_pse+0x90>
    1058:	fe 2b       	or	r31, r30
    105a:	88 0f       	add	r24, r24
    105c:	91 1d       	adc	r25, r1
    105e:	96 95       	lsr	r25
    1060:	87 95       	ror	r24
    1062:	97 f9       	bld	r25, 7
    1064:	08 95       	ret

00001066 <__udivmodsi4>:
    1066:	a1 e2       	ldi	r26, 0x21	; 33
    1068:	1a 2e       	mov	r1, r26
    106a:	aa 1b       	sub	r26, r26
    106c:	bb 1b       	sub	r27, r27
    106e:	fd 01       	movw	r30, r26
    1070:	0d c0       	rjmp	.+26     	; 0x108c <__udivmodsi4_ep>

00001072 <__udivmodsi4_loop>:
    1072:	aa 1f       	adc	r26, r26
    1074:	bb 1f       	adc	r27, r27
    1076:	ee 1f       	adc	r30, r30
    1078:	ff 1f       	adc	r31, r31
    107a:	a2 17       	cp	r26, r18
    107c:	b3 07       	cpc	r27, r19
    107e:	e4 07       	cpc	r30, r20
    1080:	f5 07       	cpc	r31, r21
    1082:	20 f0       	brcs	.+8      	; 0x108c <__udivmodsi4_ep>
    1084:	a2 1b       	sub	r26, r18
    1086:	b3 0b       	sbc	r27, r19
    1088:	e4 0b       	sbc	r30, r20
    108a:	f5 0b       	sbc	r31, r21

0000108c <__udivmodsi4_ep>:
    108c:	66 1f       	adc	r22, r22
    108e:	77 1f       	adc	r23, r23
    1090:	88 1f       	adc	r24, r24
    1092:	99 1f       	adc	r25, r25
    1094:	1a 94       	dec	r1
    1096:	69 f7       	brne	.-38     	; 0x1072 <__udivmodsi4_loop>
    1098:	60 95       	com	r22
    109a:	70 95       	com	r23
    109c:	80 95       	com	r24
    109e:	90 95       	com	r25
    10a0:	9b 01       	movw	r18, r22
    10a2:	ac 01       	movw	r20, r24
    10a4:	bd 01       	movw	r22, r26
    10a6:	cf 01       	movw	r24, r30
    10a8:	08 95       	ret

000010aa <_exit>:
    10aa:	f8 94       	cli

000010ac <__stop_program>:
    10ac:	ff cf       	rjmp	.-2      	; 0x10ac <__stop_program>
